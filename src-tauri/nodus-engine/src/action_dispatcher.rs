// src-tauri/src/observability/action_dispatcher.rs
// Action Dispatcher - UI Action Execution Gateway with Automatic Observability
// Replaces ActionDispatcher.js with the dual execution gateway pattern

use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;
use uuid::Uuid;

use crate::observability::{ObservabilityContext, AutomaticInstrumentation, ForensicLogger, MetricsRegistry};
use crate::security::{SecurityLabel, ClassificationLevel};
use crate::license::LicenseManager;
use crate::state::AppState;

/// Action Dispatcher - One of two execution gateways for automatic observability
/// Handles UI actions, state mutations, and user-initiated operations
#[derive(Debug)]
pub struct ActionDispatcher {
    // Automatic observability system
    automatic_instrumentation: AutomaticInstrumentation,
    
    // Action handler registry
    action_handlers: Arc<RwLock<HashMap<String, Box<dyn ActionHandler>>>>,
    
    // Action middleware for enterprise features
    middleware_stack: Arc<RwLock<Vec<Box<dyn ActionMiddleware>>>>,
    
    // Security context for actions
    security_context: Arc<RwLock<Option<SecurityLabel>>>,
    
    // Performance tracking
    action_performance: Arc<RwLock<HashMap<String, ActionPerformanceStats>>>,
    
    // Enterprise features
    license_manager: Arc<LicenseManager>,
    
    // Action validation
    action_validator: ActionValidator,
}

/// Action that can be dispatched through the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Action {
    pub action_type: String,
    pub payload: serde_json::Value,
    pub metadata: ActionMetadata,
}

/// Metadata for action tracking and security
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionMetadata {
    pub action_id: Uuid,
    pub user_id: String,
    pub session_id: Uuid,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub classification: ClassificationLevel,
    pub source: ActionSource,
    pub priority: ActionPriority,
    pub timeout_ms: Option<u64>,
    pub tags: HashMap<String, String>,
}

/// Source of the action for audit trails
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionSource {
    UserInterface,      // Direct UI interaction
    API,               // API call
    System,            // System-generated action
    Scheduled,         // Scheduled/cron action
    External,          // External integration
}

/// Action priority for performance optimization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionPriority {
    Critical,          // Must execute immediately
    High,              // Execute as soon as possible
    Normal,            // Standard priority
    Low,               // Can be deferred
    Background,        // Execute when system is idle
}

/// Result of action execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionResult {
    pub success: bool,
    pub data: Option<serde_json::Value>,
    pub error: Option<String>,
    pub execution_time_ms: u64,
    pub side_effects: Vec<SideEffect>,
    pub observability_metadata: ObservabilityMetadata,
}

/// Side effects generated by action execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SideEffect {
    pub effect_type: String,
    pub target: String,
    pub data: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

/// Observability metadata returned with action results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObservabilityMetadata {
    pub operation_id: String,
    pub instrumentation_applied: bool,
    pub audit_logged: bool,
    pub metrics_recorded: bool,
    pub performance_budget_status: String,
    pub middleware_executed: Vec<String>,
}

/// Performance statistics for action types
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ActionPerformanceStats {
    pub total_executions: u64,
    pub avg_duration_ms: f64,
    pub success_rate: f64,
    pub last_execution: chrono::DateTime<chrono::Utc>,
    pub slowest_execution_ms: u64,
    pub fastest_execution_ms: u64,
}

/// Action handler trait for different action types
#[async_trait::async_trait]
pub trait ActionHandler: Send + Sync {
    /// Execute the action with automatic observability
    async fn execute(
        &self,
        action: &Action,
        context: &ActionContext,
        app_state: &AppState,
    ) -> Result<serde_json::Value, ActionError>;
    
    /// Get action type handled by this handler
    fn action_type(&self) -> &str;
    
    /// Get performance budget for this action type
    fn performance_budget_ms(&self) -> u64 {
        1000 // Default 1 second
    }
    
    /// Check if action requires special permissions
    fn requires_permission(&self) -> Option<&str> {
        None
    }
}

/// Middleware for action processing pipeline
#[async_trait::async_trait]
pub trait ActionMiddleware: Send + Sync {
    /// Process action before execution
    async fn before_execute(
        &self,
        action: &mut Action,
        context: &ActionContext,
    ) -> Result<(), ActionError>;
    
    /// Process action after execution
    async fn after_execute(
        &self,
        action: &Action,
        result: &mut ActionResult,
        context: &ActionContext,
    ) -> Result<(), ActionError>;
    
    /// Get middleware name for observability
    fn name(&self) -> &str;
    
    /// Get middleware priority (lower numbers execute first)
    fn priority(&self) -> u32 {
        100
    }
}

/// Context for action execution
#[derive(Debug, Clone)]
pub struct ActionContext {
    pub user_id: String,
    pub session_id: Uuid,
    pub security_label: SecurityLabel,
    pub tenant_id: Option<String>,
    pub request_id: Uuid,
    pub source_ip: Option<String>,
    pub user_agent: Option<String>,
}

/// Action validation for security and compliance
#[derive(Debug)]
struct ActionValidator {
    // Allowed action patterns
    allowed_actions: Arc<RwLock<Vec<String>>>,
    
    // Rate limiting
    rate_limits: Arc<RwLock<HashMap<String, RateLimit>>>,
    
    // Security policies
    security_policies: Arc<RwLock<HashMap<String, SecurityPolicy>>>,
}

/// Rate limiting for action types
#[derive(Debug, Clone)]
struct RateLimit {
    pub max_requests: u32,
    pub window_seconds: u64,
    pub current_requests: u32,
    pub window_start: chrono::DateTime<chrono::Utc>,
}

/// Security policy for action types
#[derive(Debug, Clone)]
struct SecurityPolicy {
    pub required_clearance: ClassificationLevel,
    pub required_compartments: Vec<String>,
    pub audit_required: bool,
    pub approval_required: bool,
}

impl ActionDispatcher {
    /// Create new action dispatcher with automatic observability
    pub fn new(license_manager: Arc<LicenseManager>) -> Self {
        Self {
            automatic_instrumentation: AutomaticInstrumentation::new(license_manager.clone()),
            action_handlers: Arc::new(RwLock::new(HashMap::new())),
            middleware_stack: Arc::new(RwLock::new(Vec::new())),
            security_context: Arc::new(RwLock::new(None)),
            action_performance: Arc::new(RwLock::new(HashMap::new())),
            license_manager,
            action_validator: ActionValidator::new(),
        }
    }

    /// Dispatch action with automatic observability (main execution gateway method)
    pub async fn dispatch(
        &self,
        action_type: &str,
        payload: serde_json::Value,
        context: ActionContext,
        app_state: &AppState,
    ) -> Result<ActionResult, ActionError> {
        let start_time = std::time::Instant::now();
        
        // Create action with metadata
        let action = Action {
            action_type: action_type.to_string(),
            payload,
            metadata: ActionMetadata {
                action_id: Uuid::new_v4(),
                user_id: context.user_id.clone(),
                session_id: context.session_id,
                timestamp: chrono::Utc::now(),
                classification: ClassificationLevel::Internal, // Default, should be determined
                source: ActionSource::UserInterface,
                priority: ActionPriority::Normal,
                timeout_ms: None,
                tags: HashMap::new(),
            },
        };

        // Create observability context for automatic instrumentation
        let obs_context = ObservabilityContext::new(
            "action_dispatcher",
            action_type,
            action.metadata.classification.clone(),
            &context.user_id,
            context.session_id,
        );

        // Execute with automatic observability
        let result = self.automatic_instrumentation.instrument_operation(
            &obs_context,
            async {
                self.execute_action_with_middleware(&action, &context, app_state).await
            },
            app_state,
        ).await;

        let execution_time = start_time.elapsed();

        // Update performance statistics
        self.update_action_performance(action_type, execution_time, result.is_ok()).await;

        // Create action result with observability metadata
        match result {
            Ok(data) => {
                Ok(ActionResult {
                    success: true,
                    data: Some(data),
                    error: None,
                    execution_time_ms: execution_time.as_millis() as u64,
                    side_effects: Vec::new(), // TODO: Collect side effects
                    observability_metadata: ObservabilityMetadata {
                        operation_id: obs_context.operation_id.to_string(),
                        instrumentation_applied: true,
                        audit_logged: true,
                        metrics_recorded: true,
                        performance_budget_status: "OK".to_string(),
                        middleware_executed: Vec::new(), // TODO: Collect middleware names
                    },
                })
            },
            Err(error) => {
                Ok(ActionResult {
                    success: false,
                    data: None,
                    error: Some(error.to_string()),
                    execution_time_ms: execution_time.as_millis() as u64,
                    side_effects: Vec::new(),
                    observability_metadata: ObservabilityMetadata {
                        operation_id: obs_context.operation_id.to_string(),
                        instrumentation_applied: true,
                        audit_logged: true,
                        metrics_recorded: true,
                        performance_budget_status: "ERROR".to_string(),
                        middleware_executed: Vec::new(),
                    },
                })
            }
        }
    }

    /// Execute action with middleware pipeline
    async fn execute_action_with_middleware(
        &self,
        action: &Action,
        context: &ActionContext,
        app_state: &AppState,
    ) -> Result<serde_json::Value, ActionError> {
        let mut action = action.clone();

        // Validate action
        self.action_validator.validate(&action, context).await?;

        // Execute before middleware
        {
            let middleware = self.middleware_stack.read().await;
            for middleware in middleware.iter() {
                middleware.before_execute(&mut action, context).await?;
            }
        }

        // Find and execute action handler
        let handlers = self.action_handlers.read().await;
        let handler = handlers
            .get(&action.action_type)
            .ok_or_else(|| ActionError::HandlerNotFound(action.action_type.clone()))?;

        let result = handler.execute(&action, context, app_state).await;

        // Create result for middleware processing
        let mut action_result = match result {
            Ok(data) => ActionResult {
                success: true,
                data: Some(data.clone()),
                error: None,
                execution_time_ms: 0, // Will be updated later
                side_effects: Vec::new(),
                observability_metadata: ObservabilityMetadata {
                    operation_id: action.metadata.action_id.to_string(),
                    instrumentation_applied: false,
                    audit_logged: false,
                    metrics_recorded: false,
                    performance_budget_status: "OK".to_string(),
                    middleware_executed: Vec::new(),
                },
            },
            Err(ref error) => ActionResult {
                success: false,
                data: None,
                error: Some(error.to_string()),
                execution_time_ms: 0,
                side_effects: Vec::new(),
                observability_metadata: ObservabilityMetadata {
                    operation_id: action.metadata.action_id.to_string(),
                    instrumentation_applied: false,
                    audit_logged: false,
                    metrics_recorded: false,
                    performance_budget_status: "ERROR".to_string(),
                    middleware_executed: Vec::new(),
                },
            },
        };

        // Execute after middleware
        {
            let middleware = self.middleware_stack.read().await;
            for middleware in middleware.iter() {
                middleware.after_execute(&action, &mut action_result, context).await?;
            }
        }

        result
    }

    /// Register action handler
    pub async fn register_handler<H>(&self, handler: H)
    where
        H: ActionHandler + 'static,
    {
        let action_type = handler.action_type().to_string();
        let mut handlers = self.action_handlers.write().await;
        handlers.insert(action_type, Box::new(handler));
    }

    /// Add middleware to the processing pipeline
    pub async fn add_middleware<M>(&self, middleware: M)
    where
        M: ActionMiddleware + 'static,
    {
        let mut stack = self.middleware_stack.write().await;
        stack.push(Box::new(middleware));
        
        // Sort by priority (lower numbers first)
        stack.sort_by_key(|m| m.priority());
    }

    /// Get action performance statistics
    pub async fn get_action_stats(&self) -> HashMap<String, ActionPerformanceStats> {
        self.action_performance.read().await.clone()
    }

    /// Update security context for action authorization
    pub async fn set_security_context(&self, security_label: SecurityLabel) {
        let mut context = self.security_context.write().await;
        *context = Some(security_label);
    }

    /// Get list of registered action types
    pub async fn get_registered_actions(&self) -> Vec<String> {
        let handlers = self.action_handlers.read().await;
        handlers.keys().cloned().collect()
    }

    /// Update action performance statistics
    async fn update_action_performance(
        &self,
        action_type: &str,
        execution_time: std::time::Duration,
        success: bool,
    ) {
        let mut stats = self.action_performance.write().await;
        let duration_ms = execution_time.as_millis() as u64;
        
        let entry = stats.entry(action_type.to_string()).or_insert(ActionPerformanceStats {
            total_executions: 0,
            avg_duration_ms: 0.0,
            success_rate: 100.0,
            last_execution: chrono::Utc::now(),
            slowest_execution_ms: 0,
            fastest_execution_ms: u64::MAX,
        });

        entry.total_executions += 1;
        entry.avg_duration_ms = (entry.avg_duration_ms + duration_ms as f64) / 2.0;
        entry.last_execution = chrono::Utc::now();
        entry.slowest_execution_ms = entry.slowest_execution_ms.max(duration_ms);
        entry.fastest_execution_ms = entry.fastest_execution_ms.min(duration_ms);
        
        // Update success rate
        let success_count = if success { 1.0 } else { 0.0 };
        entry.success_rate = (entry.success_rate + success_count) / 2.0;
    }
}

impl ActionValidator {
    fn new() -> Self {
        Self {
            allowed_actions: Arc::new(RwLock::new(Vec::new())),
            rate_limits: Arc::new(RwLock::new(HashMap::new())),
            security_policies: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Validate action before execution
    async fn validate(&self, action: &Action, context: &ActionContext) -> Result<(), ActionError> {
        // Check if action is allowed
        self.check_action_allowed(&action.action_type).await?;
        
        // Check rate limits
        self.check_rate_limit(&action.action_type, &context.user_id).await?;
        
        // Check security policies
        self.check_security_policy(action, context).await?;
        
        Ok(())
    }

    async fn check_action_allowed(&self, action_type: &str) -> Result<(), ActionError> {
        let allowed = self.allowed_actions.read().await;
        
        // If no restrictions, allow all actions
        if allowed.is_empty() {
            return Ok(());
        }
        
        // Check if action type matches any allowed pattern
        for pattern in allowed.iter() {
            if action_type.starts_with(pattern) {
                return Ok(());
            }
        }
        
        Err(ActionError::ActionNotAllowed(action_type.to_string()))
    }

    async fn check_rate_limit(&self, action_type: &str, user_id: &str) -> Result<(), ActionError> {
        let rate_key = format!("{}:{}", action_type, user_id);
        let mut limits = self.rate_limits.write().await;
        
        if let Some(limit) = limits.get_mut(&rate_key) {
            let now = chrono::Utc::now();
            
            // Reset window if needed
            if now.signed_duration_since(limit.window_start).num_seconds() >= limit.window_seconds as i64 {
                limit.current_requests = 0;
                limit.window_start = now;
            }
            
            // Check if rate limit exceeded
            if limit.current_requests >= limit.max_requests {
                return Err(ActionError::RateLimitExceeded(action_type.to_string()));
            }
            
            limit.current_requests += 1;
        }
        
        Ok(())
    }

    async fn check_security_policy(&self, action: &Action, context: &ActionContext) -> Result<(), ActionError> {
        let policies = self.security_policies.read().await;
        
        if let Some(policy) = policies.get(&action.action_type) {
            // Check clearance level
            if context.security_label.level.rank() < policy.required_clearance.rank() {
                return Err(ActionError::InsufficientClearance {
                    required: policy.required_clearance.clone(),
                    user_level: context.security_label.level.clone(),
                });
            }
            
            // Check compartments
            for required_compartment in &policy.required_compartments {
                if !context.security_label.compartments.contains(required_compartment) {
                    return Err(ActionError::MissingCompartment(required_compartment.clone()));
                }
            }
        }
        
        Ok(())
    }
}

/// Built-in middleware for enterprise features
pub struct AuditMiddleware {
    forensic_logger: Arc<ForensicLogger>,
}

impl AuditMiddleware {
    pub fn new(forensic_logger: Arc<ForensicLogger>) -> Self {
        Self { forensic_logger }
    }
}

#[async_trait::async_trait]
impl ActionMiddleware for AuditMiddleware {
    async fn before_execute(
        &self,
        action: &mut Action,
        context: &ActionContext,
    ) -> Result<(), ActionError> {
        // Log action start
        self.forensic_logger.log_data_event(
            "action.start",
            &action.action_type,
            &context.user_id,
            context.session_id,
            action.metadata.classification.clone(),
            None,
            Some(action.payload.clone()),
        ).await.map_err(|e| ActionError::AuditError(e.to_string()))?;
        
        Ok(())
    }

    async fn after_execute(
        &self,
        action: &Action,
        result: &mut ActionResult,
        context: &ActionContext,
    ) -> Result<(), ActionError> {
        // Log action completion
        self.forensic_logger.log_data_event(
            "action.end",
            &action.action_type,
            &context.user_id,
            context.session_id,
            action.metadata.classification.clone(),
            Some(action.payload.clone()),
            result.data.clone(),
        ).await.map_err(|e| ActionError::AuditError(e.to_string()))?;
        
        Ok(())
    }

    fn name(&self) -> &str {
        "audit_middleware"
    }

    fn priority(&self) -> u32 {
        10 // High priority
    }
}

/// Built-in middleware for performance monitoring
pub struct PerformanceMiddleware {
    metrics_registry: Arc<MetricsRegistry>,
}

impl PerformanceMiddleware {
    pub fn new(metrics_registry: Arc<MetricsRegistry>) -> Self {
        Self { metrics_registry }
    }
}

#[async_trait::async_trait]
impl ActionMiddleware for PerformanceMiddleware {
    async fn before_execute(
        &self,
        action: &mut Action,
        _context: &ActionContext,
    ) -> Result<(), ActionError> {
        // Record action start metrics
        let counter_key = format!("action.{}.started", action.action_type);
        self.metrics_registry.increment_counter(&counter_key, 1);
        
        Ok(())
    }

    async fn after_execute(
        &self,
        action: &Action,
        result: &mut ActionResult,
        _context: &ActionContext,
    ) -> Result<(), ActionError> {
        // Record action completion metrics
        let status = if result.success { "success" } else { "error" };
        let counter_key = format!("action.{}.{}", action.action_type, status);
        self.metrics_registry.increment_counter(&counter_key, 1);
        
        // Record execution time
        let histogram_key = format!("action.{}.duration", action.action_type);
        self.metrics_registry.record_histogram(&histogram_key, result.execution_time_ms as f64).await;
        
        Ok(())
    }

    fn name(&self) -> &str {
        "performance_middleware"
    }

    fn priority(&self) -> u32 {
        20 // Medium priority
    }
}

/// Action execution errors
#[derive(Debug, thiserror::Error)]
pub enum ActionError {
    #[error("Action handler not found: {0}")]
    HandlerNotFound(String),
    
    #[error("Action not allowed: {0}")]
    ActionNotAllowed(String),
    
    #[error("Rate limit exceeded for action: {0}")]
    RateLimitExceeded(String),
    
    #[error("Insufficient clearance: required {required:?}, user has {user_level:?}")]
    InsufficientClearance {
        required: ClassificationLevel,
        user_level: ClassificationLevel,
    },
    
    #[error("Missing required compartment: {0}")]
    MissingCompartment(String),
    
    #[error("Audit error: {0}")]
    AuditError(String),
    
    #[error("Execution timeout")]
    Timeout,
    
    #[error("Action execution failed: {0}")]
    ExecutionFailed(String),
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::license::LicenseManager;

    // Mock action handler for testing
    struct TestActionHandler;

    #[async_trait::async_trait]
    impl ActionHandler for TestActionHandler {
        async fn execute(
            &self,
            _action: &Action,
            _context: &ActionContext,
            _app_state: &AppState,
        ) -> Result<serde_json::Value, ActionError> {
            Ok(serde_json::json!({"result": "success"}))
        }

        fn action_type(&self) -> &str {
            "test.action"
        }

        fn performance_budget_ms(&self) -> u64 {
            100
        }
    }

    #[tokio::test]
    async fn test_action_dispatcher_creation() {
        let license_manager = Arc::new(LicenseManager::new().await.unwrap());
        let dispatcher = ActionDispatcher::new(license_manager);
        
        // Test that dispatcher is created successfully
        assert!(true); // Placeholder assertion
    }

    #[tokio::test]
    async fn test_action_handler_registration() {
        let license_manager = Arc::new(LicenseManager::new().await.unwrap());
        let dispatcher = ActionDispatcher::new(license_manager);
        
        dispatcher.register_handler(TestActionHandler).await;
        
        let registered_actions = dispatcher.get_registered_actions().await;
        assert!(registered_actions.contains(&"test.action".to_string()));
    }

    #[test]
    fn test_action_metadata_creation() {
        let metadata = ActionMetadata {
            action_id: Uuid::new_v4(),
            user_id: "test-user".to_string(),
            session_id: Uuid::new_v4(),
            timestamp: chrono::Utc::now(),
            classification: ClassificationLevel::Internal,
            source: ActionSource::UserInterface,
            priority: ActionPriority::Normal,
            timeout_ms: Some(5000),
            tags: HashMap::new(),
        };
        
        assert_eq!(metadata.user_id, "test-user");
        assert_eq!(metadata.classification, ClassificationLevel::Internal);
    }
}
