

import RenderContext from "./runtime/RenderContext.js";
/**
 * @file Contains the BuildingBlockRenderer class, a composable rendering system.
 * @module BuildingBlockRenderer
 * @description This renderer focuses on composing UI from reusable "building blocks" rather than a hierarchical or level-based system.
 * @see {@link d:\Development Files\repositories\nodus\src\docs\feature_development_philosophy.md} for architectural principles on composability.
 */

/**
 * @class BuildingBlockRenderer
 * @classdesc A pure, composable rendering system that builds UI from registered building blocks. It is responsible for interpreting declarative composition objects and rendering them into DOM elements.
 * @class BuildingBlockRenderer
 * @privateFields {#componentRegistry, #metrics, #errorHelpers}
 */
export class BuildingBlockRenderer {
	/** @private @type {import('../../core/ComponentDefinition.js').ComponentDefinitionRegistry} */
	#componentRegistry;
	/** @private @type {import('../../utils/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics;
	/** @private @type {import('../../utils/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers;
	/** @private @type {import('../state/HybridStateManager.js').default|null} */
	#stateManager = null;
	/** @private @type {import('./BindEngine.js').default|null} */
	#bindEngine = null;
	/** @private @type {import('../../platform/actions/ActionDispatcher.js').ActionDispatcher|null} */
	#actionDispatcher = null;
	/** @private @type {WeakSet<Element>} */
	#dispatcherAttachedElements = new WeakSet();

	/**
	 * @class
	 * @param {object} context - The application context.
	 * @param {import('./HybridStateManager.js').default} context.stateManager - The main state manager, providing access to all other managers.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		// V8.0 Parity: Mandate 1.2 - Derive all dependencies from the stateManager.
		this.#stateManager = stateManager || null;
		this.#componentRegistry = stateManager.managers.componentRegistry;
		this.#metrics = stateManager.metricsRegistry?.namespace(
			"buildingBlockRenderer"
		);
		this.#errorHelpers = stateManager.managers.errorHelpers;
		this.#bindEngine =
			stateManager.managers?.bindEngine ??
			stateManager.managers?.stateUIBridge?.getBindEngine?.() ??
			null;
		this.#actionDispatcher =
			stateManager.managers?.actionDispatcher ??
			stateManager.managers?.actions?.dispatcher ??
			null;
	}

	/**
	 * Factory helper to construct a renderer from the application state manager.
	 * Keeps callers free from using `new` and makes the module act like a factory
	 * as required by the Phase 2 refactor plan.
	 */
	static create({ stateManager }) {
		return new BuildingBlockRenderer({ stateManager });
	}

	/**
	 * Centralized event wiring. Function handlers are attached directly. Non-function
	 * handlers (strings/objects) are delegated to the ActionDispatcher so observability
	 * remains centralized.
	 */
	#wireEvents(element, events = {}) {
		if (!events) return;

		Object.entries(events).forEach(([eventName, handler]) => {
			if (typeof handler === "function") {
				element.addEventListener(eventName, handler);
				return;
			}

			const descriptor = this.#resolveActionFromHandler(handler);
			if (!descriptor) return;

			this.#delegateAction(element, descriptor);
		});
	}

	#resolveActionFromHandler(handler) {
		if (!handler) return null;

		if (typeof handler === "string") {
			return { actionName: handler };
		}

		if (typeof handler === "object") {
			const actionName =
				handler.actionName ?? handler.name ?? handler.action ?? null;
			if (!actionName) return null;

			return {
				actionName,
				payload:
					handler.payload ?? handler.actionPayload ?? undefined,
				entityId: handler.entityId ?? undefined,
			};
		}

		return null;
	}

	#resolveActionFromProps(props = {}) {
		if (!props) return null;

		const actionName =
			props.actionName ??
			props.action ??
			props.props?.actionName ??
			props.props?.action ??
			null;

		if (!actionName) return null;

		return {
			actionName,
			payload:
				props.actionPayload ??
				props.payload ??
				props.props?.actionPayload ??
				props.props?.payload ??
				undefined,
			entityId:
				props.entityId ?? props.props?.entityId ?? undefined,
		};
	}

	#delegateAction(element, descriptor) {
		if (!descriptor?.actionName) return;

		try {
			element.dataset.action = descriptor.actionName;
		} catch {
			/* ignore dataset write failures */
		}

		if (descriptor.entityId !== undefined) {
			try {
				element.dataset.entity = descriptor.entityId;
			} catch {
				void 0;
			}
		}

		if (descriptor.payload !== undefined) {
			try {
				const serialized =
					typeof descriptor.payload === "string"
						? descriptor.payload
						: JSON.stringify(descriptor.payload);
				element.dataset.actionPayload = serialized;
			} catch {
				try {
					element.dataset.actionPayload = String(
						descriptor.payload
					);
				} catch {
					void 0;
				}
			}
		}

		if (
			this.#actionDispatcher &&
			!this.#dispatcherAttachedElements.has(element)
		) {
			try {
				this.#actionDispatcher.attach(element);
				this.#dispatcherAttachedElements.add(element);
			} catch {
				// best-effort; dispatcher attach failures are non-fatal for rendering
			}
		}
	}

	#applyActionProps(element, props = {}) {
		const descriptor = this.#resolveActionFromProps(props);
		if (descriptor) {
			this.#delegateAction(element, descriptor);
		}
	}

	#extractBindingDescriptor(props = {}) {
		const path =
			props.bindingPath ??
			props["data-bind"] ??
			props.props?.bindingPath ??
			props.props?.["data-bind"] ??
			props.binding?.path ??
			null;

		if (!path) return null;

		const optionCandidate =
			(typeof props.bindingOptions === "object" && props.bindingOptions) ||
			(typeof props.props?.bindingOptions === "object" &&
				props.props.bindingOptions) ||
			(typeof props.binding?.options === "object" &&
				props.binding.options) ||
			null;

		const options = optionCandidate ? { ...optionCandidate } : {};

		["format", "twoWay", "attr", "map", "fallback"].forEach((key) => {
			const value =
				props[key] ??
				props.props?.[key] ??
				props.binding?.[key] ??
				undefined;
			if (value !== undefined) {
				options[key] = value;
			}
		});

		return {
			path,
			options: Object.keys(options).length > 0 ? options : undefined,
		};
	}

	#applyBinding(element, props = {}) {
		const descriptor = this.#extractBindingDescriptor(props);
		if (!descriptor) return;

		try {
			element.dataset.bind = descriptor.path;
		} catch {
			// dataset assignment is best-effort
			void 0;
		}

		if (
			this.#bindEngine &&
			typeof this.#bindEngine.registerBinding === "function"
		) {
			void this.#bindEngine
				.registerBinding(
					element,
					descriptor.path,
					descriptor.options ?? {}
				)
				.catch(() => {});
		}
	}

	#assignElementProperties(element, props = {}) {
		if (!props || typeof props !== "object") return;

		const skipKeys = new Set([
			"type",
			"children",
			"events",
			"style",
			"className",
			"bindingPath",
			"bindingOptions",
			"binding",
			"bindingFormat",
			"twoWay",
			"format",
			"attr",
			"map",
			"fallback",
			"actionName",
			"action",
			"actionPayload",
			"entityId",
			"props",
		]);

		Object.entries(props).forEach(([key, value]) => {
			if (skipKeys.has(key)) return;
			try {
				element[key] = value;
			} catch {
				// ignore invalid assignments; rendering should continue
				void 0;
			}
		});
	}

	/**
	 * @function render
	 * @description Renders any composition of blocks, including single blocks, sequences, and layouts.
	 * @param {string|Array|object} composition - The composition to render.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	/**

	 * TODO: Add JSDoc for method render

	 * @memberof AutoGenerated

	 */

	render(composition, context = {}) {
		return this.#errorHelpers.tryOr(
			() => {
				this.#metrics?.increment("compositionsRendered");

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (typeof composition === "string") {
					// Single block
					return this.#renderBlock(composition, context);
				}

				if (Array.isArray(composition)) {
					// List of blocks
					return this.#renderSequence(composition, context);
				}

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (composition?.layout) {
					// Layout with blocks
					return this.#renderLayout(composition, context);
				}

				// Direct composition object
				return this.#renderComposition(composition, context);
			},
			(error) => {
				this.#metrics?.increment("renderErrors");
				return this.#createErrorElement(
					`Composition failed: ${error.message}`
				);
			}
		);
	}

	/**
	 * @function renderBlock
	 * @description Renders a single building block.
	 * @private
	 * @param {string} blockId - The ID of the block to render.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderBlock(blockId, context = {}) {
		const block = this.#componentRegistry?.get(blockId);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!block) {
			return this.#createErrorElement(`Block not found: ${blockId}`);
		}

		return this.#errorHelpers.tryOr(
			() => {
				// V8.0 Parity: Use the full RenderContext to ensure blocks have access to all system state.
				// The context needs the stateManager, which we can get from the componentRegistry.
				const renderContext = new RenderContext({
					stateManager: this.#componentRegistry?.stateManager,
					...context, // Pass through any existing context properties
					blockId,
					config: { ...block.config, ...context.config },
				});

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (typeof block.render === "function") {
					return block.render(renderContext);
				} else if (typeof block.render === "string") {
					return this.#renderTemplate(block.render, renderContext);
				}

				return this.#createErrorElement(
					`Invalid render method for ${blockId}`
				);
			},
			(error) => {
				console.error(`Error rendering block ${blockId}:`, error);
				return this.#createErrorElement(
					`Render error: ${error.message}`
				);
			}
		);
	}

	/**
	 * @function renderSequence
	 * @description Renders a sequence of blocks.
	 * @private
	 * @param {Array<string|object>} blocks - An array of block configurations.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderSequence(blocks, context = {}) {
		const container = document.createElement("div");
		container.className = "block-sequence";

		blocks.forEach((blockConfig, index) => {
			const blockContext = {
				...context,
				sequenceIndex: index,
				sequenceLength: blocks.length,
			};

			let element;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof blockConfig === "string") {
				element = this.#renderBlock(blockConfig, blockContext);
			} else {
				element = this.render(blockConfig, blockContext); // Recurse with public render
			}

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (element) {
				container.appendChild(element);
			}
		});

		return container;
	}

	/**
	 * @function renderLayout
	 * @description Renders a layout composition.
	 * @private
	 * @param {object} composition - The layout composition object.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderLayout(composition, context = {}) {
		const { layout, blocks = [], config = {} } = composition;

		const container = document.createElement("div");
		container.className = `layout-${layout}`;

		// Apply layout styles
		this.#applyLayoutStyles(container, layout, config);

		// Render blocks within layout
		blocks.forEach((blockConfig, index) => {
			const blockElement = this.render(blockConfig, {
				// Recurse with public render
				...context,
				layoutIndex: index,
				layoutType: layout,
			});

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (blockElement) {
				// Apply positioning if specified
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (blockConfig.position) {
					this.#applyPositioning(blockElement, blockConfig.position);
				}
				container.appendChild(blockElement);
			}
		});

		return container;
	}

	/**
	 * @function renderComposition
	 * @description Renders a direct composition object.
	 * @private
	 * @param {object} composition - The composition object.
	 * @param {object} [context={}] - The rendering context.
	 * @returns {HTMLElement}
	 */
	#renderComposition(composition, context = {}) {
		const {
			type = "div",
			className = "",
			style = {},
			children = [],
			events = {},
			...props
		} = composition;

		// Short-circuit rendering for well-known control types so we can use
		// small, focused helper methods that wire data-action/data-bind and
		// perform any engine initialization required.
		if (type === "button") {
			const btn = this.#renderButton(props, context);
			// Delegate event wiring to the canonical dispatcher helper
			this.#wireEvents(btn, events);
			// Append children if present
			children.forEach((child) => {
				const childElement = this.render(child, context);
				if (childElement) btn.appendChild(childElement);
			});
			return btn;
		}

		if (type === "input" || type === "text-field") {
			// Inputs typically don't have children; render a bound input and return.
			const input = this.#renderTextField(props, context);
			this.#wireEvents(input, events);
			return input;
		}

		if (type === "textarea" || type === "text-area") {
			const ta = this.#renderTextArea(props, context);
			this.#wireEvents(ta, events);
			return ta;
		}

		if (type === "label" || type === "span") {
			const lbl = this.#renderLabel(props, context);
			this.#wireEvents(lbl, events);
			return lbl;
		}

		if (type === "container") {
			const cont = this.#renderContainer(props, context);
			this.#wireEvents(cont, events);
			return cont;
		}

		const element = document.createElement(type);

		if (className) element.className = className;

		Object.assign(element.style, style);

		this.#applyBinding(element, props);
		this.#applyActionProps(element, props);

		const entityRef =
			props.entityId ?? props.props?.entityId ?? undefined;
		if (entityRef !== undefined && entityRef !== null) {
			try {
				element.dataset.entity = entityRef;
			} catch {
				void 0;
			}
		}

		this.#assignElementProperties(element, props);
		if (props.props) {
			this.#assignElementProperties(element, props.props);
		}

		// Add event listeners or delegate to ActionDispatcher via dataset
		this.#wireEvents(element, events);

		// Render children
		children.forEach((child) => {
			const childElement = this.render(child, context);
			if (childElement) element.appendChild(childElement);
		});

		return element;
	}

	/**
	 * @function applyLayoutStyles
	 * @description Applies CSS styles for a given layout type.
	 * @private
	 * @param {HTMLElement} container - The container element for the layout.
	 * @param {string} layout - The name of the layout (e.g., 'grid', 'flex').
	 * @param {object} config - The configuration for the layout.
	 * @returns {void}
	 */
	#applyLayoutStyles(container, layout, config) {
		const layoutStyles = {
			grid: {
				display: "grid",
				gridTemplateColumns: `repeat(${config.columns || 12}, 1fr)`,
				gap: `${config.gap || 16}px`,
			},
			flex: {
				display: "flex",
				flexDirection: config.direction || "row",
				gap: `${config.gap || 16}px`,
			},
			stack: {
				display: "flex",
				flexDirection: "column",
				gap: `${config.gap || 8}px`,
			},
			absolute: {
				position: "relative",
			},
		};

		const styles = layoutStyles[layout] || {};
		Object.assign(container.style, styles, config.style || {});
	}

	/**
	 * @function renderButton
	 * @description Helper to render a standardized button composition.
	 * @private
	 */
	#renderButton(props = {}, context = {}) {
		const btn = document.createElement("button");
		btn.type = props.type || "button";
		btn.className = props.className || props.props?.className || "btn";
		btn.textContent =
			props.textContent || props.props?.label || props.props?.text || "";
		Object.assign(btn.style, props.style || props.props?.style || {});

		this.#applyActionProps(btn, props);
		this.#applyBinding(btn, props);
		const entityRef =
			props.entityId ?? props.props?.entityId ?? undefined;
		if (entityRef !== undefined && entityRef !== null) {
			try {
				btn.dataset.entity = entityRef;
			} catch {
				void 0;
			}
		}
		this.#assignElementProperties(btn, props);
		if (props.props) {
			this.#assignElementProperties(btn, props.props);
		}

		return btn;
	}

	/**
	 * @function renderTextField
	 * @description Helper to render an input/text field with binding support.
	 * @private
	 */
	#renderTextField(props = {}, context = {}) {
		const input = document.createElement("input");
		input.type = props.inputType || props.type || "text";
		input.className =
			props.className || props.props?.className || "text-field";
		input.placeholder = props.placeholder || props.props?.placeholder || "";
		Object.assign(input.style, props.style || props.props?.style || {});

		this.#applyBinding(input, props);
		this.#applyActionProps(input, props);
		this.#assignElementProperties(input, props);
		if (props.props) {
			this.#assignElementProperties(input, props.props);
		}

		return input;
	}

	/**
	 * @function renderTextArea
	 * @description Helper to render a textarea with binding support.
	 * @private
	 */
	#renderTextArea(props = {}, context = {}) {
		const ta = document.createElement("textarea");
		ta.rows = props.rows || props.props?.rows || 4;
		ta.className = props.className || props.props?.className || "text-area";
		ta.placeholder = props.placeholder || props.props?.placeholder || "";
		Object.assign(ta.style, props.style || props.props?.style || {});

		this.#applyBinding(ta, props);
		this.#applyActionProps(ta, props);
		this.#assignElementProperties(ta, props);
		if (props.props) {
			this.#assignElementProperties(ta, props.props);
		}

		return ta;
	}

	/**
	 * @function renderLabel
	 * @description Helper to render a label/span; supports binding or static text.
	 * @private
	 */
	#renderLabel(props = {}, context = {}) {
		const lbl = document.createElement("span");
		lbl.className = props.className || props.props?.className || "label";
		Object.assign(lbl.style, props.style || props.props?.style || {});
		if (props.textContent) lbl.textContent = props.textContent;
		else if (props.props?.text) lbl.textContent = props.props.text;
		this.#applyBinding(lbl, props);
		this.#applyActionProps(lbl, props);
		this.#assignElementProperties(lbl, props);
		if (props.props) {
			this.#assignElementProperties(lbl, props.props);
		}

		return lbl;
	}

	/**
	 * @function renderContainer
	 * @description Helper to render a container with a layout direction and children.
	 * @private
	 */
	#renderContainer(props = {}, context = {}) {
		const cont = document.createElement("div");
		cont.className =
			props.className || props.props?.className || "container";
		const dir =
			props.layoutDirection || props.props?.layoutDirection || "column";
		Object.assign(cont.style, props.style || props.props?.style || {});
		cont.style.display = "flex";
		cont.style.flexDirection = dir === "row" ? "row" : "column";
		this.#applyBinding(cont, props);
		this.#applyActionProps(cont, props);
		this.#assignElementProperties(cont, props);
		if (props.props) {
			this.#assignElementProperties(cont, props.props);
		}

		// render children if provided
		if (Array.isArray(props.children)) {
			props.children.forEach((c) => {
				const el = this.render(c, context);
				if (el) cont.appendChild(el);
			});
		}

		return cont;
	}

	/**
	 * @function applyPositioning
	 * @description Applies positioning styles to an element within a layout.
	 * @private
	 * @param {HTMLElement} element - The element to position.
	 * @param {object} position - The positioning configuration.
	 * @returns {void}
	 */
	#applyPositioning(element, position) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (position.grid) {
			element.style.gridColumn = `${position.grid.column} / span ${position.grid.width || 1}`;
			element.style.gridRow = `${position.grid.row} / span ${position.grid.height || 1}`;
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (position.absolute) {
			element.style.position = "absolute";
			if (position.absolute.top !== undefined)
				element.style.top = `${position.absolute.top}px`;
			if (position.absolute.left !== undefined)
				element.style.left = `${position.absolute.left}px`;
			if (position.absolute.right !== undefined)
				element.style.right = `${position.absolute.right}px`;
			if (position.absolute.bottom !== undefined)
				element.style.bottom = `${position.absolute.bottom}px`;
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (position.flex) {
			element.style.flex = position.flex.grow || "1";
			if (position.flex.order !== undefined)
				element.style.order = position.flex.order;
		}
	}

	/**
	 * @function renderTemplate
	 * @description Renders a template string with context data.
	 * @private
	 * @param {string} template - The template string.
	 * @param {object} context - The data to inject into the template.
	 * @returns {HTMLElement}
	 */
	#renderTemplate(template, context) {
		let rendered = template;

		// Variable substitution
		rendered = rendered.replace(
			/\{\{(\w+(?:\.\w+)*)\}\}/g,
			(match, path) => {
				const value = this.#getNestedValue(context, path);
				return value !== undefined ? value : "";
			}
		);

		// V8.0 Parity: Mandate 2.1 - Use DOMParser exclusively for safer HTML creation.
		// The insecure `innerHTML` fallback is strictly forbidden.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (typeof DOMParser !== "undefined") {
			const parser = new DOMParser();
			const doc = parser.parseFromString(rendered, "text/html");
			const element = doc.body.firstChild;

			return doc.body.children.length === 1 ? element : doc.body;
		} else {
			// If DOMParser is not available (e.g., non-browser env), throw an error.
			throw new Error(
				"DOMParser is not available. Cannot render HTML template securely."
			);
		}
	}

	/**
	 * @function getNestedValue
	 * @description Retrieves a nested value from an object using a dot-notation path.
	 * @private
	 * @param {object} obj - The object to search.
	 * @param {string} path - The dot-notation path to the value.
	 * @returns {*} The nested value, or undefined if not found.
	 */
	#getNestedValue(obj, path) {
		return path
			.split(".")
			.reduce(
				(current, key) =>
					current && current[key] !== undefined
						? current[key]
						: undefined,
				obj
			);
	}

	/**
	 * @function createErrorElement
	 * @description Creates a standard error element.
	 * @private
	 * @param {string} message - The error message to display.
	 * @returns {HTMLElement}
	 */
	#createErrorElement(message) {
		// fire-and-forget forensic envelope; do not await in sync render path
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		}).catch(() => {});
		const error = document.createElement("div");
		error.className = "render-error";
		error.style.cssText = `
      padding: 8px;
      background: #fee;
      border: 1px solid #fcc;
      border-radius: 4px;
      color: #c33;
      font-size: 12px;
    `;
		error.textContent = message;
		return error;
	}

	/**
	 * @function getAvailableBlocks
	 * @description Retrieves a list of all registered block IDs.
	 * @public
	 * @returns {Array<string>}
	 */
	/**

	 * TODO: Add JSDoc for method getAvailableBlocks

	 * @memberof AutoGenerated

	 */

	getAvailableBlocks() {
		return (
			this.#componentRegistry
				?.getByCategory("building-block")
				.map((def) => def.id) || []
		);
	}

	/**
	 * @function getBlockDefinition
	 * @description Retrieves the definition for a specific block.
	 * @public
	 * @param {string} blockId - The ID of the block.
	 * @returns {object|undefined} The block definition, or undefined if not found.
	 */
	/**

	 * TODO: Add JSDoc for method getBlockDefinition

	 * @memberof AutoGenerated

	 */

	getBlockDefinition(blockId) {
		return this.#componentRegistry?.get(blockId);
	}
}

// Helper functions for creating common compositions

/**
 * @function createModalComposition
 * @description Creates a composition for a modal dialog.
 * @param {Array|object} content - The content to display inside the modal.
 * @param {object} [config={}] - Configuration for the modal.
 * @returns {object} A composition object.
 */
export function createModalComposition(content, config = {}) {
	ForensicLogger.createEnvelope({
		actorId: "system",
		action: "<auto>",
		target: "<unknown>",
		label: "unclassified",
	}).catch(() => {});
	return {
		layout: "absolute",
		config: { style: { position: "relative" } },
		blocks: [
			{
				type: "div",
				className: "modal-overlay",
				style: {
					position: "fixed",
					top: "0",
					left: "0",
					width: "100%",
					height: "100%",
					backgroundColor: "rgba(0,0,0,0.5)",
					display: "flex",
					alignItems: "center",
					justifyContent: "center",
					zIndex: "1000",
				},
				events: {
					click: (e) => {
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (e.target === e.currentTarget && config.onClose) {
							config.onClose();
						}
					},
				},
				children: [
					{
						type: "div",
						className: "modal-content",
						style: {
							backgroundColor: "white",
							borderRadius: "8px",
							padding: "24px",
							maxWidth: config.maxWidth || "600px",
							maxHeight: config.maxHeight || "80vh",
							overflow: "auto",
							...config.contentStyle,
						},
						children: Array.isArray(content) ? content : [content],
					},
				],
			},
		],
	};
}

/**
 * @function createFormComposition
 * @description Creates a composition for a form.
 * @param {Array<object>} fields - An array of field definitions for the form.
 * @param {object} [config={}] - Configuration for the form.
 * @returns {object} A composition object.
 */
export function createFormComposition(fields, config = {}) {
	ForensicLogger.createEnvelope({
		actorId: "system",
		action: "<auto>",
		target: "<unknown>",
		label: "unclassified",
	}).catch(() => {});
	const formFields = fields.map((field) => ({
		layout: "stack",
		blocks: [
			field.label
				? {
						type: "label",
						textContent: field.label,
						style: { marginBottom: "4px", fontWeight: "bold" },
					}
				: null,
			{
				type: "input",
				...field.input,
				style: {
					padding: "8px 12px",
					border: "1px solid #ddd",
					borderRadius: "4px",
					marginBottom: "16px",
					...field.input?.style,
				},
			},
		].filter(Boolean),
	}));

	return {
		type: "form",
		className: "composition-form",
		events: {
			submit: config.onSubmit || ((e) => e.preventDefault()),
		},
		children: [
			...formFields,
			config.showSubmit !== false
				? {
						type: "button",
						textContent: config.submitText || "Submit",
						style: {
							padding: "12px 24px",
							backgroundColor: "#007bff",
							color: "white",
							border: "none",
							borderRadius: "4px",
							cursor: "pointer",
						},
					}
				: null,
		].filter(Boolean),
	};
}

/**
 * @function createCardComposition
 * @description Creates a composition for a card element.
 * @param {Array|object} content - The content of the card.
 * @param {object} [config={}] - Configuration for the card.
 * @returns {object} A composition object.
 */
export function createCardComposition(content, config = {}) {
	ForensicLogger.createEnvelope({
		actorId: "system",
		action: "<auto>",
		target: "<unknown>",
		label: "unclassified",
	}).catch(() => {});
	return {
		type: "div",
		className: "composition-card",
		style: {
			backgroundColor: "white",
			border: "1px solid #ddd",
			borderRadius: "8px",
			padding: "16px",
			boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
			...config.style,
		},
		children: Array.isArray(content) ? content : [content],
	};
}

export default BuildingBlockRenderer;
