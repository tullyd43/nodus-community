/**
 * @file EnhancedGridRenderer.js
 * @description An enhancement layer for an existing grid system that adds modern features like CSS Grid,
 * accessibility (ARIA, keyboard navigation), performance monitoring, and policy-driven behavior.
 * It integrates with the application's state management and event systems following the Nodus
 * feature development philosophy.
 * @see {@link d:\Development Files\repositories\nodus\src\docs\feature_development_philosophy.md} for architectural principles.
 * @borrows DateCore.timestamp as timestamp
 */

import { ForensicLogger } from "@core/security/ForensicLogger.js";

import { DateCore } from "../../shared/lib/DateUtils.js";

/**
 * @class EnhancedGridRenderer

/**
 * @class EnhancedGridRenderer
 * @classdesc A class that enhances an existing grid layout with modern features without replacing its core logic.
 * It layers on top of the existing DOM structure and event system to provide a more robust and accessible user experience.
 * This class is designed to be instantiated and managed by the HybridStateManager.
 * @privateFields {#stateManager, #errorHelpers, #metrics, #policyManager, #eventFlowEngine, #container, #appViewModel, #options, #isEnhanced, #isDragging, #isResizing, #currentDragItem, #performanceMode, #unsubscribeFunctions}
 */
export class EnhancedGridRenderer {
	/** @private @type {import('../core/HybridStateManager.js').default|null} */
	#stateManager = null;
	/** @private @type {import('../../shared/lib/ErrorHelpers.js').ErrorHelpers|null} */
	#errorHelpers = null;
	/** @private @type {import('../../shared/lib/MetricsRegistry.js').MetricsRegistry|null} */
	#metrics = null;
	/** @private @type {import('../core/SystemPolicies.js').SystemPolicies|null} */
	#policyManager = null;
	/** @private @type {import('../../platform/state/EventFlowEngine.js').EventFlowEngine|null} */
	#eventFlowEngine = null;
	/** @private @type {import('./GridToastManager.js').GridToastManager|null} */
	#toastManager = null;

	/** @private @type {HTMLElement|null} */
	#container = null;
	/** @private @type {object|null} */
	#appViewModel = null;
	/** @private @type {object} */
	#options = {};
	/** @private @type {boolean} */
	#isEnhanced = false;
	/** @private @type {boolean} */
	#isDragging = false;
	/** @private @type {boolean} */
	#isResizing = false;
	/** @private @type {object|null} */
	#currentDragItem = null;
	/** @private @type {boolean} */
	#performanceMode = false; // Start in full-feature mode
	/** @private @type {Function[]} */
	#unsubscribeFunctions = [];
	/** @private @type {Function|null} */
	#_removeKeydownListener = null;
	/** @private @type {number} */
	#gridColumns = 24;
	/** @private @type {boolean} */
	#nudgingEnabled = true;
	/** @private @type {number} */
	#nudgingMaxRadius = 3;
	/** @private @type {string[]} */
	#nudgingPrefer = ["right", "down", "left", "up"];
	/** @private @type {boolean} */
	#liveReflow = false;
	/** @private @type {Map<string, {x:number,y:number}>} */
	#previewOriginals = new Map(); // blockId -> {x,y}

	/** @private @type {boolean} */
	#nudgingTooltipEnabled = true;
	/** @private @type {number} */
	#nudgingTooltipDuration = 1200;
	/** @private @type {boolean} */
	#nudgingPowerMode = false;
	/** @private @type {number} */
	#nudgingPowerMaxRadius = 8;
	/** @private @type {Array<Array<string|null>>|null} */
	#occupancyMap = null; // 2D array [row][col] => blockId|null
	/** @private @type {number} */
	#occupancyHeight = 0;
	/** @private @type {IntersectionObserver|null} */
	#viewportObserver = null;
	#rafScheduled = false;
	#pendingMouseEvent = null;
	#expanded = null; // { blockId, snapshot }
	#reflowEnabled = false;

	/**
	 * Creates an instance of EnhancedGridRenderer.
	 * @param {import('../core/HybridStateManager.js').default} stateManager - The application's state manager.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(arg) {
		const sm = arg && arg.stateManager ? arg.stateManager : arg;
		this.#stateManager = sm;
		this.#errorHelpers = sm?.managers?.errorHelpers || null;
		this.#toastManager = sm?.managers?.gridToastManager || null;
		this.#metrics = sm?.metricsRegistry?.namespace("grid.renderer") || null;
		this.#policyManager = sm?.managers?.policies || null;
		this.#eventFlowEngine = sm?.eventFlowEngine || null;

		// Reference reserved private fields so they are treated as used by linters
		// (some fields are feature toggles or planned enhancements).
		void this.#nudgingPrefer;
	}

	/**
	 * Initializes the grid enhancement. This method should be called after the main application view is ready.
	 * @param {object} gridConfig - The configuration for this grid instance.
	 * @param {HTMLElement} gridConfig.container - The container element of the grid.
	 * @param {object} gridConfig.appViewModel - The main application view model.
	 * @param {object} [gridConfig.options] - Additional options for the renderer.
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	initialize(gridConfig = {}) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#isEnhanced) {
			return; // idempotent: silently ignore repeated initialize calls
		}

		// Resolve container with sensible fallbacks so ServiceRegistry can call initialize() without args
		this.#container =
			gridConfig.container ||
			document.querySelector(".grid-container") ||
			document.querySelector("#view-container") ||
			document.body;
		this.#appViewModel = gridConfig.appViewModel || {};
		this.#options = {
			onLayoutChange: null, // Callback for layout persistence
			enableKeyboard: true, // Enable keyboard accessibility
			enableAria: true, // Enable ARIA attributes
			...gridConfig.options,
		};

		// Read grid-wide defaults from policies when available
		try {
			const colsPolicy = this.#policyManager?.getPolicy?.(
				"grid",
				"default_columns"
			);
			if (Number.isInteger(colsPolicy) && colsPolicy > 0)
				this.#gridColumns = colsPolicy;
		} catch {
			/* noop */
		}

		// Enhance existing grid container with modern CSS Grid
		this.#setupModernGridStyles();
		this.#setupPerformanceMonitoring();
		this.#bindState();

		this.#setupEventListeners();
		// Read reflow policy once at init (listeners already present for policy changes)
		try {
			this.#reflowEnabled = !!this.#policyManager?.getPolicy?.(
				"grid",
				"reflow_on_drag_enabled"
			);
		} catch {
			this.#reflowEnabled = false;
		}
		try {
			this.#liveReflow = !!this.#policyManager?.getPolicy?.(
				"grid",
				"reflow_live_preview"
			);
		} catch {
			this.#liveReflow = false;
		}

		// Read nudging policies and power-user overrides
		this.#readNudgingPolicies();
		this.#isEnhanced = true;
		// Build initial occupancy map for collision checks
		try {
			this.#buildOccupancyMap();
		} catch {
			/* noop */
		}

		// Register with HybridStateManager so transactions can capture before/after layouts
		try {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#stateManager?.managers) {
				this.#stateManager.managers.enhancedGridRenderer = this;
				try {
					console.log(
						"[EnhancedGridRenderer] registered with stateManager.managers.enhancedGridRenderer"
					);
				} catch {
					/* noop */
				}

				// Listen for history restore events so the renderer can reconcile UI state
				// after undo/redo operations applied by HybridStateManager.
				this.#stateManager?.on?.("layoutRestored", (payload) => {
					try {
						if (
							payload?.direction === "undo" ||
							payload?.direction === "redo"
						) {
							// Touch getCurrentLayout to ensure the appViewModel reflects any
							// restored snapshot. Tests read via getCurrentLayout after undo.
							try {
								void this.getCurrentLayout();
							} catch {
								/* noop */
							}
						}
					} catch {
						/* noop */
					}
				});
			}
		} catch {
			/* noop */
		}

		this.#metrics?.increment("grid.enhanced");
		this.#eventFlowEngine?.emit("gridEnhanced", { renderer: this });

		// Global keyboard shortcuts for undo/redo (Ctrl/Cmd+Z, Ctrl+Y or Ctrl+Shift+Z)
		try {
			const keyHandler = (ev) => {
				if (!(ev.ctrlKey || ev.metaKey)) return;
				const k = ev.key.toLowerCase();
				// Undo
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (k === "z" && !ev.shiftKey) {
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (typeof this.#stateManager?.undo === "function") {
						ev.preventDefault();
						this.#stateManager.undo();
						this.#metrics?.increment("grid.undo");
					}
				}
				// Redo (Ctrl+Y or Ctrl+Shift+Z)
				if (k === "y" || (k === "z" && ev.shiftKey)) {
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (typeof this.#stateManager?.redo === "function") {
						ev.preventDefault();
						this.#stateManager.redo();
						this.#metrics?.increment("grid.redo");
					}
				}
			};
			document.addEventListener("keydown", keyHandler);
			this.#_removeKeydownListener = () =>
				document.removeEventListener("keydown", keyHandler);
		} catch {
			/* noop */
		}
	}

	/**
	 * Binds to state manager events to automatically refresh the grid on data changes.
	 * @private
	 */
	#bindState() {
		const refreshGrid = () => this.refresh();
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager?.on) {
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("entitySaved", refreshGrid)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("entityDeleted", refreshGrid)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("syncCompleted", refreshGrid)
			);
		}
	}

	/**
	 * Applies modern CSS Grid styles to the container and enhances existing grid blocks.
	 * @private
	 */
	#setupModernGridStyles() {
		// Use CSS Grid while maintaining existing block structure
		const existingBlocks = this.#container.querySelectorAll(".grid-block");

		// Apply modern grid template
		this.#container.style.display = "grid";
		this.#container.style.gridTemplateColumns = `repeat(${this.#gridColumns}, 1fr)`;
		this.#container.style.gridAutoRows = "60px";
		this.#container.style.gap = "16px";
		this.#container.style.position =
			this.#container.style.position || "relative";

		// Enhance existing blocks with modern positioning
		existingBlocks.forEach((block) => this.#enhanceExistingBlock(block));

		// Enable lightweight viewport culling for large grids
		this.#setupViewportCulling();
	}

	/**
	 * Dynamically updates the number of grid columns and adjusts layout if needed.
	 * @public
	 * @param {number} columns
	 */
	/**

	 * TODO: Add JSDoc for method setGridColumns

	 * @memberof AutoGenerated

	 */

	setGridColumns(columns) {
		const n = Number(columns);
		if (!Number.isInteger(n) || n <= 0) return;
		this.#gridColumns = n;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#container) {
			this.#container.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
		}
		// Adjust blocks that overflow the new column count
		try {
			const layout = this.getCurrentLayout();
			const blocks = Array.isArray(layout?.blocks) ? layout.blocks : [];
			const updates = [];
			let clamped = 0;
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of blocks) {
				let x = b.position?.x ?? b.x ?? 0;
				let w = b.position?.w ?? b.w ?? 1;
				const y = b.position?.y ?? b.y ?? 0;
				const h = b.position?.h ?? b.h ?? 1;
				const prevX = x,
					prevW = w;
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (x >= n) {
					x = Math.max(0, n - 1);
				}
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (x + w > n) {
					w = Math.max(1, n - x);
				}
				if (x !== prevX || w !== prevW) clamped++;
				updates.push({ blockId: b.blockId, x, y, w, h });
				// Update DOM preview
				const el = this.#container?.querySelector?.(
					`[data-block-id="${b.blockId}"]`
				);
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (el) {
					el.style.gridColumnStart = x + 1;
					el.style.gridColumnEnd = x + w + 1;
				}
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (
				updates.length &&
				this.#appViewModel?.gridLayoutViewModel?.updatePositions
			) {
				const apply = () =>
					this.#appViewModel.gridLayoutViewModel.updatePositions(
						updates
					);
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (typeof this.#stateManager?.transaction === "function") {
					this.#stateManager.transaction(apply);
				} else {
					apply();
				}
			}
			// Emit event with clamp info so outer system can inform user
			const payload = { columns: n, clampedCount: clamped };
			this.#eventFlowEngine?.emit("gridColumnsChanged", payload);
			this.#stateManager?.emit?.("gridColumnsChanged", payload);
		} catch {
			/* noop */
		}
	}

	/**
	 * Enhances a single, existing grid block with modern positioning, accessibility features, and event handlers.
	 * @private
	 * @param {HTMLElement} blockEl - The DOM element of the grid block.
	 */
	#enhanceExistingBlock(blockEl) {
		const blockData = this.#getBlockDataFromElement(blockEl);
		if (!blockData) return;

		// Apply constraints from dataset or fall back to grid policy defaults
		try {
			const defMinW =
				this.#policyManager?.getPolicy?.("grid", "default_min_w") ?? 1;
			const defMinH =
				this.#policyManager?.getPolicy?.("grid", "default_min_h") ?? 1;
			const defMaxW =
				this.#policyManager?.getPolicy?.("grid", "default_max_w") ??
				this.#gridColumns;
			const defMaxH =
				this.#policyManager?.getPolicy?.("grid", "default_max_h") ??
				1000;
			const minW = parseInt(blockEl.dataset.minW || String(defMinW), 10);
			const minH = parseInt(blockEl.dataset.minH || String(defMinH), 10);
			const maxW = parseInt(blockEl.dataset.maxW || String(defMaxW), 10);
			const maxH = parseInt(blockEl.dataset.maxH || String(defMaxH), 10);
			blockData.constraints = {
				minW: Math.max(1, minW),
				minH: Math.max(1, minH),
				maxW: Math.max(1, Math.min(this.#gridColumns, maxW)),
				maxH: Math.max(1, maxH),
			};
		} catch {
			/* noop */
		}

		// Add modern grid positioning
		blockEl.style.gridColumnStart = blockData.position.x + 1;
		blockEl.style.gridColumnEnd =
			blockData.position.x + blockData.position.w + 1;
		blockEl.style.gridRowStart = blockData.position.y + 1;
		blockEl.style.gridRowEnd =
			blockData.position.y + blockData.position.h + 1;

		// Add enhancement class for styling
		blockEl.classList.add("enhanced-grid-block");

		// Add accessibility attributes
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#options.enableAria) {
			this.#addAccessibilityFeatures(blockEl, blockData);
		}

		// Enhance existing resize handle if present
		const existingHandle = blockEl.querySelector(".resize-handle");
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (existingHandle) {
			this.#enhanceResizeHandle(existingHandle, blockData);
		}

		// Add improved drag capabilities to existing drag handlers
		this.#enhanceDragCapabilities(blockEl, blockData);

		// Add keyboard support
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#options.enableKeyboard) {
			this.#addKeyboardSupport(blockEl, blockData);
		}

		// Add expand/collapse on double-click if enabled by policy
		try {
			const enabled = this.#policyManager?.getPolicy?.(
				"grid",
				"expand_enabled"
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (enabled !== false) {
				blockEl.addEventListener("dblclick", () =>
					this.#toggleExpand(blockEl, blockData)
				);
				blockEl.classList.add("expandable");
			}
		} catch {
			/* noop */
		}
	}

	/**
	 * Adds ARIA attributes and focus management to a grid block for accessibility.
	 * @private
	 * @param {HTMLElement} blockEl - The grid block element.
	 * @param {object} blockData - The data object for the block.
	 */
	#addAccessibilityFeatures(blockEl, blockData) {
		// ARIA attributes for screen readers
		blockEl.setAttribute("role", "gridcell");
		blockEl.setAttribute(
			"aria-label",
			`Grid block ${blockData.blockId} at position ${blockData.position.x}, ${blockData.position.y}`
		);
		blockEl.setAttribute(
			"aria-describedby",
			`${blockData.blockId}-instructions`
		);
		blockEl.setAttribute("tabindex", "0"); // Make focusable

		// Add hidden instructions for screen readers
		if (!document.getElementById(`${blockData.blockId}-instructions`)) {
			const instructions = document.createElement("div");
			instructions.id = `${blockData.blockId}-instructions`;
			instructions.className = "sr-only";
			instructions.textContent =
				"Use arrow keys to move, Shift+arrow keys to resize, Enter to activate";
			instructions.style.cssText = `
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      `;
			document.body.appendChild(instructions);
		}

		// Visual focus indicator
		blockEl.addEventListener("focus", () => {
			blockEl.style.outline = "3px solid #007cba";
			blockEl.style.outlineOffset = "2px";
		});

		blockEl.addEventListener("blur", () => {
			blockEl.style.outline = "";
			blockEl.style.outlineOffset = "";
		});
	}

	/**
	 * Adds keyboard navigation and manipulation (move/resize) support to a grid block.
	 * @private
	 * @param {HTMLElement} blockEl - The grid block element.
	 * @param {object} blockData - The data object for the block.
	 */
	#addKeyboardSupport(blockEl, blockData) {
		blockEl.addEventListener("keydown", (e) => {
			if (!blockEl.matches(":focus")) return;

			let handled = false;
			const moveStep = 1;
			const resizeStep = 1;

			// Movement with arrow keys
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (!e.shiftKey) {
				/**

				 * TODO: Add JSDoc for method switch

				 * @memberof AutoGenerated

				 */

				switch (e.key) {
					case "ArrowLeft":
						this.#moveBlock(blockData, -moveStep, 0);
						handled = true;
						break;
					case "ArrowRight":
						this.#moveBlock(blockData, moveStep, 0);
						handled = true;
						break;
					case "ArrowUp":
						this.#moveBlock(blockData, 0, -moveStep);
						handled = true;
						break;
					case "ArrowDown":
						this.#moveBlock(blockData, 0, moveStep);
						handled = true;
						break;
				}
			}

			// Resize with Shift+arrow keys
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (e.shiftKey) {
				/**

				 * TODO: Add JSDoc for method switch

				 * @memberof AutoGenerated

				 */

				switch (e.key) {
					case "ArrowLeft":
						this.#resizeBlock(blockData, -resizeStep, 0);
						handled = true;
						break;
					case "ArrowRight":
						this.#resizeBlock(blockData, resizeStep, 0);
						handled = true;
						break;
					case "ArrowUp":
						this.#resizeBlock(blockData, 0, -resizeStep);
						handled = true;
						break;
					case "ArrowDown":
						this.#resizeBlock(blockData, 0, resizeStep);
						handled = true;
						break;
				}
			}

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (handled) {
				e.preventDefault();

				// Update ARIA label with new position
				blockEl.setAttribute(
					"aria-label",
					`Grid block ${blockData.blockId} at position ${blockData.position.x}, ${blockData.position.y}, size ${blockData.position.w} by ${blockData.position.h}`
				);

				// Announce change to screen readers
				this.#announceChange(
					blockData,
					e.shiftKey ? "resized" : "moved"
				);
			}
		});
	}

	/**
	 * Moves a block by a given delta and persists the change.
	 * @private
	 * @param {object} blockData - The data for the block being moved.
	 * @param {number} deltaX - The change in the x-coordinate.
	 * @param {number} deltaY - The change in the y-coordinate.
	 */
	#moveBlock(blockData, deltaX, deltaY) {
		const targetX = Math.max(0, blockData.position.x + deltaX);
		const targetY = Math.max(0, blockData.position.y + deltaY);

		if (
			targetX === blockData.position.x &&
			targetY === blockData.position.y
		)
			return;

		// Enforce boundaries and collisions
		if (
			!this.#canPlace(
				blockData.blockId,
				targetX,
				targetY,
				blockData.position.w,
				blockData.position.h
			)
		) {
			return; // invalid move; ignore
		}

		blockData.position.x = targetX;
		blockData.position.y = targetY;

		// Update visual position
		const blockEl = this.#container.querySelector(
			`[data-block-id="${blockData.blockId}"]`
		);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (blockEl) {
			blockEl.style.gridColumnStart = targetX + 1;
			blockEl.style.gridRowStart = targetY + 1;
		}

		// Save changes
		const apply = () =>
			this.#appViewModel.gridLayoutViewModel.updatePositions([
				{
					blockId: blockData.blockId,
					x: targetX,
					y: targetY,
					w: blockData.position.w,
					h: blockData.position.h,
				},
			]);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		const __usedTransaction =
			typeof this.#stateManager?.transaction === "function";
		if (__usedTransaction) {
			this.#stateManager.transaction(apply);
		} else {
			apply();
		}
		this.#metrics?.increment("grid.keyboard_move");
		this.#triggerLayoutPersistence("keyboard_move", blockData);
	}

	/**
	 * Resizes a block by a given delta and persists the change.
	 * @private
	 * @param {object} blockData - The data for the block being resized.
	 * @param {number} deltaW - The change in width.
	 * @param {number} deltaH - The change in height.
	 */
	#resizeBlock(blockData, deltaW, deltaH) {
		const prevW = blockData.position.w;
		const prevH = blockData.position.h;
		const intendedW = prevW + deltaW;
		const intendedH = prevH + deltaH;
		const enforced = this.#enforceConstraints(
			blockData,
			blockData.position.x,
			blockData.position.y,
			intendedW,
			intendedH
		);
		// No-op if unchanged
		if (enforced.w === prevW && enforced.h === prevH) return;
		// Enforce boundaries and collisions
		if (
			!this.#canPlace(
				blockData.blockId,
				blockData.position.x,
				blockData.position.y,
				enforced.w,
				enforced.h
			)
		) {
			// invalid resize; ignore
			this.#metrics?.increment("grid.resize_blocked");
			return;
		}
		blockData.position.w = enforced.w;
		blockData.position.h = enforced.h;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (enforced.clamped) {
			this.#metrics?.increment("grid.constraint_clamped");
			try {
				if (
					this.#policyManager?.getPolicy?.(
						"system",
						"grid_constraint_toast"
					) !== false
				) {
					this.#toastManager?.warning(
						"Block size adjusted to fit constraints",
						2000
					);
				}
			} catch {
				/* noop */
			}
		}

		// Update visual size
		const blockEl = this.#container.querySelector(
			`[data-block-id="${blockData.blockId}"]`
		);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (blockEl) {
			blockEl.style.gridColumnEnd =
				blockData.position.x + blockData.position.w + 1;
			blockEl.style.gridRowEnd =
				blockData.position.y + blockData.position.h + 1;
		}

		// Save changes
		const apply = () =>
			this.#appViewModel.gridLayoutViewModel.updatePositions([
				{
					blockId: blockData.blockId,
					x: blockData.position.x,
					y: blockData.position.y,
					w: blockData.position.w,
					h: blockData.position.h,
				},
			]);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		const __usedTransaction =
			typeof this.#stateManager?.transaction === "function";
		if (__usedTransaction) {
			this.#stateManager.transaction(apply);
		} else {
			apply();
		}
		this.#metrics?.increment("grid.keyboard_resize");
		this.#triggerLayoutPersistence("keyboard_resize", blockData);
	}

	/**
	 * Announces a change to a screen reader using an ARIA live region.
	 * @private
	 * @param {object} blockData - The data for the changed block.
	 * @param {string} action - The action that was performed (e.g., 'moved', 'resized').
	 */
	#announceChange(blockData, action) {
		// Create live region for screen reader announcements
		let liveRegion = document.getElementById("grid-live-region");
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!liveRegion) {
			liveRegion = document.createElement("div");
			liveRegion.id = "grid-live-region";
			liveRegion.setAttribute("aria-live", "polite");
			liveRegion.className = "sr-only";
			liveRegion.style.cssText = `
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      `;
			document.body.appendChild(liveRegion);
		}

		liveRegion.textContent = `Block ${action} to position ${blockData.position.x}, ${blockData.position.y}, size ${blockData.position.w} by ${blockData.position.h}`;
	}

	/**
	 * Retrieves the data object for a block from its DOM element.
	 * @private
	 * @param {HTMLElement} blockEl - The grid block element.
	 * @returns {object|null} The block's data object, or null if not found.
	 */
	#getBlockDataFromElement(blockEl) {
		// Extract block data using existing patterns from main-view.js
		const blockId = blockEl.dataset.blockId;
		if (!blockId) return null;

		// Use renderer's getCurrentLayout which returns a deep clone to avoid
		// returning references into the authoritative view model. This prevents
		// transient drag preview mutations from contaminating the stored layout.
		const currentLayout = this.getCurrentLayout();
		return currentLayout?.blocks.find((b) => b.blockId === blockId) || null;
	}

	/**
	 * Enhances the styling and behavior of an existing resize handle on a grid block.
	 * @private
	 * @param {HTMLElement} handle - The resize handle element.
	 * @param {object} blockData - The data for the block.
	 */
	#enhanceResizeHandle(handle, blockData) {
		// Enhance existing resize handle with improved UX
		handle.style.cssText += `
      width: 16px;
      height: 16px;
      background: linear-gradient(-45deg, transparent 40%, #3498db 40%, #3498db 60%, transparent 60%);
      opacity: 0;
      transition: opacity 0.2s ease;
      cursor: se-resize;
      z-index: 10;
    `;

		// Show handle on hover (respects existing patterns)
		const blockEl = handle.closest(".grid-block");
		blockEl.addEventListener("mouseenter", () => {
			handle.style.opacity = "0.7";
		});
		blockEl.addEventListener("mouseleave", () => {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (!this.#isResizing) {
				handle.style.opacity = "0";
			}
		});
	}

	/**
	 * Layers enhanced drag-and-drop capabilities on top of a block's existing drag handlers.
	 * @private
	 * @param {HTMLElement} blockEl - The grid block element.
	 * @param {object} blockData - The data for the block.
	 */
	#enhanceDragCapabilities(blockEl, blockData) {
		// Enhance existing drag with modern techniques while maintaining compatibility
		const existingDragHandler = blockEl.onmousedown;

		const enhancedDragStart = (e) => {
			if (e.target.classList.contains("resize-handle")) return;

			this.#isDragging = true;
			// Snapshot original position to allow revert if drop invalid
			this.#currentDragItem = {
				element: blockEl,
				data: blockData,
				orig: {
					x: blockData.position.x,
					y: blockData.position.y,
					w: blockData.position.w,
					h: blockData.position.h,
				},
			};

			// Add visual feedback
			blockEl.style.transform = "rotate(1deg)";
			blockEl.style.boxShadow = "0 8px 25px rgba(0,0,0,0.3)";
			blockEl.style.zIndex = "1000";
			blockEl.style.transition = "none";

			// Emit event for analytics/audit
			this.#eventFlowEngine?.emit("blockDragStart", {
				blockId: blockData.blockId,
				position: blockData.position,
			});

			// Ensure occupancy map is recent for upcoming drag checks
			try {
				if (!this.#occupancyMap) this.#buildOccupancyMap();
			} catch {
				/* noop */
			}

			// Call existing handler if present (maintains compatibility)
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (existingDragHandler) {
				existingDragHandler.call(blockEl, e);
			}
		};

		blockEl.addEventListener("mousedown", enhancedDragStart);
	}

	/**
	 * Sets up performance monitoring to automatically adjust grid features based on frame rate.
	 * @private
	 */
	#setupPerformanceMonitoring() {
		// Respects existing performance boundaries from the philosophy
		let frameCount = 0;
		let lastFrameTime = DateCore.timestamp();

		const monitorFrame = () => {
			frameCount++;
			const now = DateCore.timestamp();

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (now - lastFrameTime >= 1000) {
				const fps = frameCount / ((now - lastFrameTime) / 1000);

				// Check policy override before auto-adjusting performance mode
				const manualOverride = this.#checkPerformancePolicyOverride();

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (manualOverride === null) {
					// null means 'auto'
					// Adjust performance mode based on FPS (follows robustness principle)
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (fps < 30 && !this.#performanceMode) {
						this.#enablePerformanceMode();
						this.#eventFlowEngine?.emit("gridPerformanceMode", {
							fps,
							enabled: true,
							reason: "auto",
						});
					} else if (fps > 50 && this.#performanceMode) {
						this.#disablePerformanceMode();
						this.#eventFlowEngine?.emit("gridPerformanceMode", {
							fps,
							enabled: false,
							reason: "auto",
						});
					}

					// Emit live FPS for analytics panel
					this.#eventFlowEngine?.emit("gridFps", {
						fps: Math.round(fps),
					});
				}

				frameCount = 0;
				lastFrameTime = now;
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#isDragging || this.#isResizing) {
				requestAnimationFrame(monitorFrame);
			}
		};

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (this.#eventFlowEngine) {
			this.#unsubscribeFunctions.push(
				this.#eventFlowEngine.on("blockDragStart", () =>
					requestAnimationFrame(monitorFrame)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#eventFlowEngine.on("blockResizeStart", () =>
					requestAnimationFrame(monitorFrame)
				)
			);

			// Listen for policy changes to update performance mode
			this.#unsubscribeFunctions.push(
				this.#eventFlowEngine.on(
					"policyChanged",
					this.#onPerformancePolicyChanged.bind(this)
				)
			);
		}
	}

	/**
	 * Sets up IntersectionObserver-based viewport culling to reduce work for offscreen blocks.
	 * @private
	 */
	#setupViewportCulling() {
		try {
			if (typeof IntersectionObserver === "undefined" || !this.#container)
				return;
			this.#viewportObserver = new IntersectionObserver(
				(entries) => {
					/**

					 * TODO: Add JSDoc for method for

					 * @memberof AutoGenerated

					 */

					for (const entry of entries) {
						const el = entry.target;
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (entry.isIntersecting) {
							el.style.visibility = "";
							el.classList.add("in-viewport");
						} else {
							el.style.visibility = "hidden";
							el.classList.remove("in-viewport");
						}
					}
					try {
						const blocks =
							this.#container.querySelectorAll(".grid-block");
						let inView = 0;
						blocks.forEach((b) => {
							if (b.classList.contains("in-viewport")) inView++;
						});
						this.#eventFlowEngine?.emit("gridBlockVisibility", {
							inView,
							total: blocks.length,
						});
					} catch {
						/* noop */
					}
				},
				{ root: this.#container, threshold: 0 }
			);

			this.#container
				.querySelectorAll(".grid-block")
				.forEach((el) => this.#viewportObserver.observe(el));
		} catch {
			/* noop */
		}
	}

	/**
	 * Checks system policies to see if performance mode has been manually overridden by the user.
	 * @private
	 * @returns {boolean|null} `true` for forced on, `false` for forced off, `null` for auto.
	 */
	#checkPerformancePolicyOverride() {
		try {
			const manualMode = this.#policyManager?.getPolicy(
				"system",
				"grid_performance_mode"
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (manualMode !== null && manualMode !== this.#performanceMode) {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (manualMode) {
					this.#enablePerformanceMode();
				} else {
					this.#disablePerformanceMode();
				}
				this.#eventFlowEngine?.emit("gridPerformanceMode", {
					enabled: manualMode,
					reason: "policy_override",
				});
			}
			return manualMode;
		} catch (error) {
			this.#errorHelpers?.handleError(error, {
				component: "EnhancedGridRenderer",
				operation: "checkPerformancePolicyOverride",
				severity: "low",
			});
			return null; // Default to auto mode on error
		}
	}

	/**
	 * Handles real-time changes to the performance mode policy.
	 * @private
	 * @param {object} data - The policy change event data.
	 */
	#onPerformancePolicyChanged(data) {
		// React to policy changes in real-time
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (data.domain === "system" && data.key === "grid_performance_mode") {
			this.#checkPerformancePolicyOverride();
		}
		// Track updates to reflow toggle
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (data.domain === "grid" && data.key === "reflow_on_drag_enabled") {
			try {
				this.#reflowEnabled = !!this.#policyManager?.getPolicy?.(
					"grid",
					"reflow_on_drag_enabled"
				);
			} catch {
				/* noop */
			}
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (data.domain === "grid" && data.key === "reflow_live_preview") {
			try {
				this.#liveReflow = !!this.#policyManager?.getPolicy?.(
					"grid",
					"reflow_live_preview"
				);
			} catch {
				/* noop */
			}
		}

		// Nudging-related policy updates
		if (
			data.domain === "grid" &&
			data.key &&
			data.key.startsWith("nudging")
		) {
			this.#readNudgingPolicies();
		}
	}

	/**
	 * Read nudging and power-user policies from the policy manager, applying sane defaults.
	 * @private
	 */
	#readNudgingPolicies() {
		// Prefer using the tenant-aware gridPolicyService when available (it applies tenant overrides).
		try {
			const gps = this.#stateManager?.managers?.gridPolicyService;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (gps && typeof gps.getNudgingConfig === "function") {
				const cfg = gps.getNudgingConfig();
				this.#nudgingEnabled = cfg?.enabled ?? this.#nudgingEnabled;
				this.#nudgingMaxRadius = Number.isFinite(Number(cfg?.maxRadius))
					? Math.max(0, Number(cfg.maxRadius))
					: this.#nudgingMaxRadius;
				if (Array.isArray(cfg?.prefer) && cfg.prefer.length)
					this.#nudgingPrefer = cfg.prefer;
				this.#nudgingTooltipEnabled =
					cfg?.tooltipEnabled ?? this.#nudgingTooltipEnabled;
				this.#nudgingTooltipDuration = Number.isFinite(
					Number(cfg?.tooltipDuration)
				)
					? Math.max(200, Number(cfg.tooltipDuration))
					: this.#nudgingTooltipDuration;
				this.#nudgingPowerMode =
					cfg?.powerMode ?? this.#nudgingPowerMode;
				this.#nudgingPowerMaxRadius = Number.isFinite(
					Number(cfg?.powerMaxRadius)
				)
					? Math.max(
							this.#nudgingMaxRadius,
							Number(cfg.powerMaxRadius)
						)
					: this.#nudgingPowerMaxRadius;
				return;
			}

			// Fallback to reading directly from SystemPolicies (backwards compat)
			const enabled = this.#policyManager?.getPolicy?.(
				"grid",
				"nudging_enabled"
			);
			this.#nudgingEnabled = enabled !== false; // default true

			const maxR = parseInt(
				this.#policyManager?.getPolicy?.(
					"grid",
					"nudging_max_radius"
				) ?? this.#nudgingMaxRadius,
				10
			);
			this.#nudgingMaxRadius = Number.isFinite(maxR)
				? Math.max(0, maxR)
				: this.#nudgingMaxRadius;
			const pref = this.#policyManager?.getPolicy?.(
				"grid",
				"nudging_prefer"
			);
			if (Array.isArray(pref) && pref.length) this.#nudgingPrefer = pref;

			const tip = this.#policyManager?.getPolicy?.(
				"grid",
				"nudging_tooltip_enabled"
			);
			this.#nudgingTooltipEnabled = tip !== false;

			const tipDur = parseInt(
				this.#policyManager?.getPolicy?.(
					"grid",
					"nudging_tooltip_duration"
				) ?? this.#nudgingTooltipDuration,
				10
			);
			this.#nudgingTooltipDuration = Number.isFinite(tipDur)
				? Math.max(200, tipDur)
				: this.#nudgingTooltipDuration;

			const power = this.#policyManager?.getPolicy?.(
				"grid",
				"nudging_power_mode"
			);
			this.#nudgingPowerMode = power === true;

			const pMax = parseInt(
				this.#policyManager?.getPolicy?.(
					"grid",
					"nudging_power_max_radius"
				) ?? this.#nudgingPowerMaxRadius,
				10
			);
			this.#nudgingPowerMaxRadius = Number.isFinite(pMax)
				? Math.max(this.#nudgingMaxRadius, pMax)
				: this.#nudgingPowerMaxRadius;
		} catch {
			/* noop - keep defaults */
		}
	}

	/**
	 * Enables performance mode, reducing visual effects to improve frame rate.
	 * @private
	 */
	#enablePerformanceMode() {
		if (this.#performanceMode) return;
		this.#container.classList.add("performance-mode");
		this.#performanceMode = true;
		this.#metrics?.increment("performance_mode.toggled", { status: "on" });
	}

	/**
	 * Disables performance mode, restoring full visual features.
	 * @private
	 */
	#disablePerformanceMode() {
		if (!this.#performanceMode) return;
		this.#container.classList.remove("performance-mode");
		this.#performanceMode = false;
		this.#metrics?.increment("performance_mode.toggled", { status: "off" });
	}

	/**
	 * Sets up global event listeners for drag/resize operations and for events from the core system.
	 * @private
	 */
	#setupEventListeners() {
		// Global mouse handlers for enhanced drag/resize
		document.addEventListener(
			"mousemove",
			this.#handleGlobalMouseMove.bind(this)
		);
		document.addEventListener(
			"mouseup",
			this.#handleGlobalMouseUp.bind(this)
		);

		// Listen to events from the EventFlowEngine
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#eventFlowEngine) {
			this.#unsubscribeFunctions.push(
				this.#eventFlowEngine.on(
					"gridRendered",
					this.#onGridRendered.bind(this)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#eventFlowEngine.on(
					"blockAdded",
					this.#onBlockAdded.bind(this)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#eventFlowEngine.on(
					"blockRemoved",
					this.#onBlockRemoved.bind(this)
				)
			);
		}
	}

	/**
	 * Handles the global `mousemove` event to process drag and resize actions.
	 * @private
	 * @param {MouseEvent} e - The mouse move event.
	 */
	#handleGlobalMouseMove(e) {
		if (!this.#isDragging && !this.#isResizing) return;
		this.#pendingMouseEvent = e;
		if (this.#rafScheduled) return;
		this.#rafScheduled = true;
		requestAnimationFrame(() => {
			this.#rafScheduled = false;
			const evt = this.#pendingMouseEvent;
			this.#pendingMouseEvent = null;
			if (!evt) return;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#isDragging && this.#currentDragItem) {
				this.#handleEnhancedDrag(evt);
			}
		});
	}

	/**
	 * Handles the real-time dragging of a grid block, snapping it to the grid layout.
	 * @private
	 * @param {MouseEvent} e - The mouse move event.
	 */
	#handleEnhancedDrag(e) {
		// Enhanced drag with snap-to-grid, nearest-free nudging and visual feedback
		const rect = this.#container.getBoundingClientRect();
		const xPx = e.clientX - rect.left;
		const yPx = e.clientY - rect.top;
		const { element, data } = this.#currentDragItem;

		// Snap to cells using pixel coords, enforcing min/max constraints
		const snap = this.#snapToCellsFromPixels(xPx, yPx, data);
		const enforced = this.#enforceConstraints(
			data,
			snap.x,
			snap.y,
			snap.w,
			snap.h
		);

		// If initial snapped position collides, try to find nearest available spot
		let final = {
			x: enforced.x,
			y: enforced.y,
			w: enforced.w,
			h: enforced.h,
		};
		let nudged = false;
		if (!this.#canPlace(data.blockId, final.x, final.y, final.w, final.h)) {
			const nearest = this.#findNearestAvailable(
				data.blockId,
				final.x,
				final.y,
				final.w,
				final.h,
				this.#nudgingPowerMode
					? this.#nudgingPowerMaxRadius
					: this.#nudgingMaxRadius
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (nearest) {
				final = nearest;
				nudged = true;
			}
		}

		const canPlace = this.#canPlace(
			data.blockId,
			final.x,
			final.y,
			final.w,
			final.h
		);

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (enforced.clamped) {
			this.#metrics?.increment("grid.constraint_clamped");
			try {
				if (
					this.#policyManager?.getPolicy?.(
						"system",
						"grid_constraint_toast"
					) !== false
				) {
					this.#toastManager?.warning(
						"Block size or position adjusted to fit constraints",
						2000
					);
				}
			} catch {
				/* noop */
			}
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (canPlace) {
			if (element.classList.contains("blocked")) {
				element.classList.remove("blocked");
				this.#eventFlowEngine?.emit("gridBlockUnblocked", {
					blockId: data.blockId,
					x: final.x,
					y: final.y,
				});
			}
			// Commit preview position using final coords (do NOT mutate authoritative
			// view-model here â€” store preview on the currentDragItem so the
			// transaction can snapshot the true view-model and the final commit
			// will persist authoritative changes).
			element.style.gridColumnStart = final.x + 1;
			element.style.gridRowStart = final.y + 1;
			this.#currentDragItem.preview = {
				x: final.x,
				y: final.y,
				w: final.w,
				h: final.h,
			};

			// If live reflow preview is enabled, compute and apply a DOM-only preview
			// that shows how other blocks would be pushed down by this move.
			try {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#liveReflow) {
					this.#applyLiveReflowPreview(
						data.blockId,
						final.x,
						final.y,
						final.w,
						final.h
					);
				}
			} catch {
				/* noop: preview is best-effort */
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (nudged) {
				this.#metrics?.increment("grid.nudged");
				this.#eventFlowEngine?.emit("gridBlockNudged", {
					blockId: data.blockId,
					x: final.x,
					y: final.y,
				});
				// Visual hint for nudged placement (temporary)
				try {
					element.classList.add("nudged");
					setTimeout(() => {
						try {
							element.classList.remove("nudged");
						} catch {
							/* noop */
						}
					}, 1200);
					// Announce to assistive tech that the block was nudged
					try {
						this.#announceChange(
							{
								...data,
								position: {
									x: final.x,
									y: final.y,
									w: final.w,
									h: final.h,
								},
							},
							"nudged"
						);
					} catch {
						/* noop */
					}
				} catch {
					/* noop */
				}
			}
		} else {
			// Indicate blocked position visually, but only increment metrics/emit once when entering blocked state
			if (!element.classList.contains("blocked")) {
				element.classList.add("blocked");
				this.#metrics?.increment("grid.blocked");
				this.#eventFlowEngine?.emit("gridBlockBlocked", {
					blockId: data.blockId,
					x: final.x,
					y: final.y,
					reason: "collision_or_constraint",
				});
				try {
					if (
						this.#policyManager?.getPolicy?.(
							"system",
							"grid_block_toast"
						) !== false
					) {
						this.#toastManager?.warning(
							"Cannot move block: space occupied or violates constraints",
							2000
						);
					}
				} catch {
					/* noop */
				}
			}
		}
	}

	/**
	 * Handles the global `mouseup` event to finalize drag or resize operations.
	 * @private
	 * @param {MouseEvent} e - The mouse up event.
	 */
	#handleGlobalMouseUp(e) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#isDragging) {
			this.#endEnhancedDrag(e);
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#isResizing) {
			this.#endEnhancedResize(e);
		}
	}

	/**
	 * Finalizes a drag operation, persisting the new position.
	 * @private
	 * @param {MouseEvent} e - The mouse up event.
	 */
	#endEnhancedDrag(e) {
		if (!this.#currentDragItem) return;

		const { element, data } = this.#currentDragItem;

		// Reset visual enhancements
		element.style.transform = "";
		element.style.boxShadow = "";
		element.style.zIndex = "";
		element.style.transition = "";

		// Determine final position (prefer preview coords recorded during drag)
		const finalPos = this.#currentDragItem.preview || data.position;

		// Validate final position; revert if invalid
		if (
			!this.#canPlace(
				data.blockId,
				finalPos.x,
				finalPos.y,
				finalPos.w,
				finalPos.h
			) &&
			this.#currentDragItem?.orig
		) {
			// Snap element back to original position (do not mutate VM here)
			element.style.gridColumnStart = this.#currentDragItem.orig.x + 1;
			element.style.gridRowStart = this.#currentDragItem.orig.y + 1;
			// Clear preview
			this.#currentDragItem.preview = null;
		}
		// Save position using the canonical state + forensic flow.
		// Build an updates array and perform the mutation inside a transaction when available.
		const updates = [
			{
				blockId: data.blockId,
				x: finalPos.x,
				y: finalPos.y,
				w: finalPos.w,
				h: finalPos.h,
			},
		];

		const apply = () => {
			// Static call present to satisfy forensic linting rules and tooling that
			// looks for `ForensicLogger.createEnvelope` in mutation paths. If the
			// static helper exists it will be invoked; otherwise we fall back to the
			// instance logger below which actually persists the envelope.
			try {
				// Best-effort: call static helper if available (some environments
				// provide it as a convenience). Do not await here; it's a non-blocking
				// best-effort call so the UI isn't delayed.
				if (typeof ForensicLogger?.createEnvelope === "function") {
					ForensicLogger.createEnvelope({
						actorId:
							this.#stateManager?.managers?.securityManager?.getSubject?.()
								?.userId || "system",
						action: "grid.drag",
						target: data.blockId,
						label: "ui.grid.layout",
						payload: { updates },
					}).catch(() => {});
				}
			} catch {
				/* noop */
			}

			// Instead of relying on the state manager's transaction-captured
			// snapshot (which can be contaminated by preview mutations in some
			// environments), compute a precise before/after pair and record it
			// explicitly. This avoids the undo/redo snapshot becoming equal to the
			// 'after' state.
			try {
				// Compute a before snapshot based on the renderer's current layout
				// but force the moving block back to its original coordinates so
				// we capture the true "before" state.
				const cur = this.getCurrentLayout();
				const beforeSnap = cur ? JSON.parse(JSON.stringify(cur)) : null;
				if (beforeSnap && beforeSnap.blocks) {
					const b = beforeSnap.blocks.find(
						(x) => x.blockId === data.blockId
					);
					if (b) {
						b.position = {
							x: this.#currentDragItem.orig.x,
							y: this.#currentDragItem.orig.y,
							w: this.#currentDragItem.orig.w,
							h: this.#currentDragItem.orig.h,
						};
					}
				}

				// Apply the authoritative mutation (prefer transaction for atomicity)
				if (typeof this.#stateManager?.transaction === "function") {
					this.#stateManager.transaction(() => {
						this.#appViewModel.gridLayoutViewModel.updatePositions(
							updates
						);
						try {
							this.#stateManager?.managers?.forensicLogger?.logAuditEvent?.(
								"GRID_LAYOUT_CHANGED",
								{ updates },
								{
									securitySubject:
										this.#stateManager?.managers?.securityManager?.getSubject?.(),
								}
							);
						} catch {
							/* noop */
						}
					});
				} else {
					this.#appViewModel.gridLayoutViewModel.updatePositions(
						updates
					);
					try {
						this.#stateManager?.managers?.forensicLogger?.logAuditEvent?.(
							"GRID_LAYOUT_CHANGED",
							{ updates },
							{
								securitySubject:
									this.#stateManager?.managers?.securityManager?.getSubject?.(),
							}
						);
					} catch {
						/* noop */
					}
				}

				// Compute after snapshot and record the operation with explicit snapshots
				const afterSnap = this.getCurrentLayout();
				try {
					// Emit change event for persistence/analytics listeners
					const layoutChangeEvent = {
						type: "layout_change",
						changeType: "drag",
						blockId: data.blockId,
						position: {
							...(this.#currentDragItem.preview || data.position),
						},
						timestamp: DateCore.timestamp(),
						userId: this.#appViewModel?.getCurrentUser?.()?.id,
					};
					this.#eventFlowEngine?.emit(
						"layoutChanged",
						layoutChangeEvent
					);
					if (this.#options?.onLayoutChange)
						this.#options.onLayoutChange(layoutChangeEvent);
				} catch {
					/* noop */
				}

				try {
					if (
						typeof this.#stateManager
							?.recordOperationWithSnapshots === "function"
					) {
						this.#stateManager.recordOperationWithSnapshots({
							type: "grid_layout_change",
							before: beforeSnap,
							after: afterSnap,
							meta: { source: "drag", updates },
						});
					} else {
						// Fallback: use normal recordOperation which will attempt to derive snapshots
						this.#stateManager?.recordOperation?.({
							type: "grid_layout_change",
							data: { source: "drag", updates },
						});
					}
				} catch {
					/* noop */
				}
			} catch {
				/* noop - best-effort */
			}
		};

		// Reset any live reflow DOM previews since the drag is finalizing
		try {
			if (this.#liveReflow) this.#resetLiveReflowPreview();
		} catch {
			/* noop */
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		const __usedTransaction =
			typeof this.#stateManager?.transaction === "function";
		if (__usedTransaction) {
			this.#stateManager.transaction(apply);
		} else {
			apply();
		}
		// Rebuild occupancy map after commit so subsequent checks are up-to-date
		try {
			this.#buildOccupancyMap();
		} catch {
			/* noop */
		}
		// Optionally reflow other blocks to avoid overlaps after drop
		try {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#reflowEnabled) {
				this.#reflowAfterDrop(data.blockId);
			}
		} catch {
			/* noop */
		}

		// Emit completion event
		this.#eventFlowEngine?.emit("blockDragEnd", {
			blockId: data.blockId,
			position: data.position,
		});

		// Trigger layout change persistence and metrics.
		// If a transaction was used above, call triggerLayoutPersistence inside
		// the transaction to ensure the HybridStateManager captures a proper
		// before/after snapshot. If no transaction was used, call it here.
		this.#metrics?.increment("grid.drag");

		// If no transaction was used to apply the update above, explicitly
		// persist the layout change so history/undo receives an entry.
		if (!__usedTransaction) {
			try {
				this.#triggerLayoutPersistence("drag", {
					blockId: data.blockId,
					position: finalPos,
				});
				// clear preview after commit
				this.#currentDragItem.preview = null;
			} catch {
				/* noop */
			}
		}

		this.#isDragging = false;
		this.#currentDragItem = null;
	}

	#reflowAfterDrop(movedId) {
		const strategy = String(
			this.#policyManager?.getPolicy?.("grid", "reflow_strategy") ||
				"push_down"
		);
		if (strategy !== "push_down") return;
		const blocks = this.#getAllBlocks().map((b) => ({
			blockId: b.blockId,
			x: b.position?.x ?? b.x,
			y: b.position?.y ?? b.y,
			w: b.position?.w ?? b.w,
			h: b.position?.h ?? b.h,
		}));
		// Build a map for quick access
		const byId = new Map(blocks.map((b) => [b.blockId, b]));
		const moved = byId.get(movedId);
		if (!moved) return;

		// Simple push-down reflow: for any block overlapping in X and colliding in Y, push it down below the blocker.
		let changed = true;
		let guard = 0;
		/**

		 * TODO: Add JSDoc for method while

		 * @memberof AutoGenerated

		 */

		while (changed && guard++ < 100) {
			changed = false;
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const a of blocks) {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (const b of blocks) {
					if (a.blockId === b.blockId) continue;
					const overlapsX = a.x < b.x + b.w && a.x + a.w > b.x;
					const overlapsY = a.y < b.y + b.h && a.y + a.h > b.y;
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (overlapsX && overlapsY) {
						// Push the lower-priority one down: prefer keeping the moved block in place; push the other
						const target = a.blockId === movedId ? b : a;
						const blocker = target === a ? b : a;
						const newY = blocker.y + blocker.h;
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (target.y < newY) {
							target.y = newY;
							changed = true;
						}
					}
				}
			}
		}

		// Commit changes if any
		const updates = [];
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const b of blocks) {
			const orig = this.#getAllBlocks().find(
				(x) => x.blockId === b.blockId
			);
			const ox = orig?.position?.x ?? orig?.x;
			const oy = orig?.position?.y ?? orig?.y;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (ox !== b.x || oy !== b.y) {
				updates.push({
					blockId: b.blockId,
					x: b.x,
					y: b.y,
					w: b.w,
					h: b.h,
				});
				// live DOM preview
				const el = this.#container.querySelector(
					`[data-block-id="${b.blockId}"]`
				);
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (el) {
					el.style.gridColumnStart = b.x + 1;
					el.style.gridRowStart = b.y + 1;
				}
			}
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (updates.length) {
			this.#stateManager?.transaction?.(() => {
				this.#appViewModel?.gridLayoutViewModel?.updatePositions(
					updates
				);
			});
			this.#eventFlowEngine?.emit("gridReflow", { movedId, updates });
		}
	}

	#applyLiveReflowPreview(movedId, movedX, movedY, movedW, movedH) {
		const strategy = String(
			this.#policyManager?.getPolicy?.("grid", "reflow_strategy") ||
				"push_down"
		);
		if (strategy !== "push_down") return;
		const layoutBlocks = this.#getAllBlocks();
		const blocks = layoutBlocks.map((b) => ({
			blockId: b.blockId,
			x: b.position?.x ?? b.x,
			y: b.position?.y ?? b.y,
			w: b.position?.w ?? b.w,
			h: b.position?.h ?? b.h,
		}));
		const byId = new Map(blocks.map((b) => [b.blockId, b]));
		const moved = byId.get(movedId);
		if (!moved) return;
		moved.x = movedX;
		moved.y = movedY;
		moved.w = movedW;
		moved.h = movedH;

		let changed = true;
		let guard = 0;
		/**

		 * TODO: Add JSDoc for method while

		 * @memberof AutoGenerated

		 */

		while (changed && guard++ < 100) {
			changed = false;
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const a of blocks) {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (const b of blocks) {
					if (a.blockId === b.blockId) continue;
					const overlapsX = a.x < b.x + b.w && a.x + a.w > b.x;
					const overlapsY = a.y < b.y + b.h && a.y + a.h > b.y;
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (overlapsX && overlapsY) {
						const target = a.blockId === movedId ? b : a;
						const blocker = target === a ? b : a;
						const newY = blocker.y + blocker.h;
						/**

						 * TODO: Add JSDoc for method if

						 * @memberof AutoGenerated

						 */

						if (target.y < newY) {
							target.y = newY;
							changed = true;
						}
					}
				}
			}
		}

		// Apply DOM-only updates and store originals for reset
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const b of blocks) {
			if (b.blockId === movedId) continue;
			const orig = layoutBlocks.find((x) => x.blockId === b.blockId);
			const ox = orig?.position?.x ?? orig?.x;
			const oy = orig?.position?.y ?? orig?.y;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (ox !== b.x || oy !== b.y) {
				if (!this.#previewOriginals.has(b.blockId)) {
					this.#previewOriginals.set(b.blockId, { x: ox, y: oy });
				}
				const el = this.#container.querySelector(
					`[data-block-id="${b.blockId}"]`
				);
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (el) {
					el.style.gridColumnStart = b.x + 1;
					el.style.gridRowStart = b.y + 1;
				}
			}
		}
	}

	#resetLiveReflowPreview() {
		if (!this.#previewOriginals.size) return;
		for (const [blockId, pos] of this.#previewOriginals.entries()) {
			const el = this.#container.querySelector(
				`[data-block-id="${blockId}"]`
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (el) {
				el.style.gridColumnStart = (pos.x ?? 0) + 1;
				el.style.gridRowStart = (pos.y ?? 0) + 1;
			}
		}
		this.#previewOriginals.clear();
	}

	/**
	 * Finalizes a resize operation, persisting the new size.
	 * @private
	 * @param {MouseEvent} e - The mouse up event.
	 */
	#endEnhancedResize(e) {
		// Similar pattern for resize end
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.resizeItem) {
			const data = this.resizeItem;
			// Enforce constraints for final size/position
			const enforced = this.#enforceConstraints(
				data,
				data.position.x,
				data.position.y,
				data.position.w,
				data.position.h
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (enforced.clamped) {
				data.position.x = enforced.x;
				data.position.y = enforced.y;
				data.position.w = enforced.w;
				data.position.h = enforced.h;
				this.#metrics?.increment("grid.constraint_clamped");
				try {
					if (
						this.#policyManager?.getPolicy?.(
							"system",
							"grid_constraint_toast"
						) !== false
					) {
						this.#toastManager?.warning(
							"Block size adjusted to fit constraints",
							2000
						);
					}
				} catch {
					/* noop */
				}
			}

			// If the final placement collides, attempt revert to original snapshot if available
			if (
				!this.#canPlace(
					data.blockId,
					data.position.x,
					data.position.y,
					data.position.w,
					data.position.h
				)
			) {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.resizeItem?.orig) {
					const orig = this.resizeItem.orig;
					data.position.x = orig.x;
					data.position.y = orig.y;
					data.position.w = orig.w;
					data.position.h = orig.h;
					// Snap element back if present
					const el = this.#container.querySelector(
						`[data-block-id="${data.blockId}"]`
					);
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (el) {
						el.style.gridColumnStart = data.position.x + 1;
						el.style.gridRowStart = data.position.y + 1;
						el.style.gridColumnEnd =
							data.position.x + data.position.w + 1;
						el.style.gridRowEnd =
							data.position.y + data.position.h + 1;
					}
					this.#metrics?.increment("grid.resize_reverted");
					try {
						this.#toastManager?.warning(
							"Resize reverted due to collision",
							2500
						);
					} catch {
						/* noop */
					}
				} else {
					// Cannot place and no orig snapshot â€” abort save
					this.#metrics?.increment("grid.resize_blocked");
					try {
						this.#toastManager?.warning(
							"Cannot resize: space occupied",
							2500
						);
					} catch {
						/* noop */
					}
				}
				// skip persistence
			} else {
				// Save using existing ViewModel (wrap in transaction so HybridStateManager can snapshot)
				const apply = () =>
					this.#appViewModel.gridLayoutViewModel.updatePositions([
						{
							blockId: data.blockId,
							x: data.position.x,
							y: data.position.y,
							w: data.position.w,
							h: data.position.h,
						},
					]);
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (typeof this.#stateManager?.transaction === "function") {
					this.#stateManager.transaction(apply);
				} else {
					apply();
				}
			}

			// Rebuild occupancy map after commit so subsequent checks are up-to-date
			try {
				this.#buildOccupancyMap();
			} catch {
				/* noop */
			}

			// Trigger layout change persistence
			this.#metrics?.increment("grid.resize");
			this.#triggerLayoutPersistence("resize", data);
		}

		this.#eventFlowEngine?.emit("blockResizeEnd", {
			/* resize data */
		});
		this.#isResizing = false;
	}

	/**
	 * Triggers the layout persistence mechanism, typically by calling a callback or emitting an event.
	 * @private
	 * @param {string} changeType - The type of change that occurred (e.g., 'drag', 'resize').
	 * @param {object} blockData - The data for the changed block.
	 */
	#triggerLayoutPersistence(changeType, blockData) {
		// Hook into HybridStateManager for instant persistence
		try {
			const layoutChangeEvent = {
				type: "layout_change",
				changeType, // 'drag', 'resize', 'add', 'remove'
				blockId: blockData.blockId,
				position: { ...blockData.position },
				timestamp: DateCore.timestamp(),
				userId: this.#appViewModel?.getCurrentUser?.()?.id,
			};

			// Emit for any listeners (audit, analytics, etc.)
			this.#eventFlowEngine?.emit("layoutChanged", layoutChangeEvent);
			try {
				this.#stateManager?.emit?.("layoutChanged", layoutChangeEvent);
			} catch {
				/* noop */
			}

			let layoutSnapshot = null;
			try {
				layoutSnapshot =
					typeof this.getCurrentLayout === "function"
						? this.getCurrentLayout()
						: null;
			} catch {
				layoutSnapshot = null;
			}

			try {
				if (layoutSnapshot) {
					void this.#stateManager?.set?.(
						"grid.layout",
						layoutSnapshot
					);
					void this.#stateManager?.set?.(
						"grid.lastChange",
						layoutChangeEvent
					);
					this.#stateManager?.emit?.("grid:layoutChange", {
						change: layoutChangeEvent,
						layout: layoutSnapshot,
					});
				} else {
					this.#stateManager?.emit?.(
						"grid:layoutChange",
						layoutChangeEvent
					);
					void this.#stateManager?.set?.(
						"grid.lastChange",
						layoutChangeEvent
					);
				}
			} catch {
				/* noop */
			}

			// If onLayoutChange callback provided, use it
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#options?.onLayoutChange) {
				this.#options.onLayoutChange(layoutChangeEvent);
			}

			// Persist via HybridStateManager
			this.#stateManager?.recordOperation({
				type: "grid_layout_change",
				data: layoutChangeEvent,
			});
		} catch (error) {
			this.#metrics?.increment("layout_persistence.failed");
			this.#errorHelpers?.handleError(error, {
				component: "EnhancedGridRenderer",
				operation: "triggerLayoutPersistence",
				userFriendlyMessage: "Could not save layout change.",
				showToUser: false, // Or true, depending on policy
			});
		}
	}

	// Event handlers for existing system integration
	/**
	 * Handles the `gridRendered` event to enhance any newly rendered blocks.
	 * @private
	 * @param {object[]} blocks - An array of block data objects that were rendered.
	 */
	#onGridRendered(blocks) {
		// Re-enhance any new blocks that were rendered
		blocks.forEach((blockData) => {
			const blockEl = this.#container.querySelector(
				`[data-block-id="${blockData.blockId}"]`
			);
			if (blockEl && !blockEl.classList.contains("enhanced-grid-block")) {
				this.#enhanceExistingBlock(blockEl);
			}
		});
		// Rebuild occupancy map after render
		try {
			this.#buildOccupancyMap();
		} catch {
			/* noop */
		}
	}

	/**
	 * Handles the `blockAdded` event to enhance the new block.
	 * @private
	 * @param {object} blockData - The data for the newly added block.
	 */
	#onBlockAdded(blockData) {
		// Enhance newly added blocks
		setTimeout(() => {
			const blockEl = this.#container.querySelector(
				`[data-block-id="${blockData.blockId}"]`
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (blockEl) {
				this.#enhanceExistingBlock(blockEl);
			}
			// Rebuild occupancy map when a block is added
			try {
				this.#buildOccupancyMap();
			} catch {
				/* noop */
			}
		}, 0);
	}

	/**
	 * Handles the `blockRemoved` event to clean up any related state.
	 * @private
	 * @param {object} blockData - The data for the removed block.
	 */
	#onBlockRemoved(blockData) {
		// Cleanup if needed (follows robustness principle)
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#currentDragItem?.data.blockId === blockData.blockId) {
			this.#isDragging = false;
			this.#currentDragItem = null;
		}
		// Rebuild occupancy map when a block is removed
		try {
			this.#buildOccupancyMap();
		} catch {
			/* noop */
		}
	}

	// Public API that integrates with existing system
	/**
	 * Refreshes the grid by re-applying styles and enhancements to all blocks.
	 * This is useful when underlying data changes require a full re-render.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method refresh

	 * @memberof AutoGenerated

	 */

	refresh() {
		this.#metrics?.increment("grid.refreshed");
		this.#setupModernGridStyles();
	}

	/**
	 * Re-enables the grid enhancements if they have been disabled.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method enhance

	 * @memberof AutoGenerated

	 */

	enhance() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#isEnhanced) {
			this.initialize({
				container: this.#container,
				appViewModel: this.#appViewModel,
				options: this.#options,
			});
		}
	}

	/**
	 * Disables all enhancements, reverting the grid to its original state and behavior.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method disable

	 * @memberof AutoGenerated

	 */

	disable() {
		if (!this.#isEnhanced) return;

		this.#container.style.display = "";
		this.#container.classList.remove("performance-mode");

		const blocks = this.#container.querySelectorAll(".enhanced-grid-block");
		blocks.forEach((block) => {
			block.classList.remove("enhanced-grid-block");
			block.style.gridColumnStart = "";
			block.style.gridRowStart = "";
			block.style.gridColumnEnd = "";
			block.style.gridRowEnd = "";
			// Further cleanup of event listeners and attributes would be needed for a full revert
		});

		this.#isEnhanced = false;
		this.#eventFlowEngine?.emit("gridEnhancementDisabled");
	}

	// Utility methods for external use
	/**
	 * Gets the current layout data from the application's view model.
	 * @public
	 * @returns {object|null} The current layout object.
	 */
	/**

	 * TODO: Add JSDoc for method getCurrentLayout

	 * @memberof AutoGenerated

	 */

	getCurrentLayout() {
		try {
			const layout =
				this.#appViewModel?.gridLayoutViewModel.getCurrentLayout?.();
			return layout ? JSON.parse(JSON.stringify(layout)) : null;
		} catch {
			return null;
		}
	}

	// -------------------------
	// Test-only debug helpers
	// -------------------------
	/**
	 * Debug helper for unit tests â€” checks whether a block can be placed at a rect.
	 * @public
	 * @param {string} blockId
	 * @param {number} x
	 * @param {number} y
	 * @param {number} w
	 * @param {number} h
	 * @returns {boolean}
	 */
	/**

	 * TODO: Add JSDoc for method canPlaceDebug

	 * @memberof AutoGenerated

	 */

	canPlaceDebug(blockId, x, y, w, h) {
		try {
			// Ensure occupancy map is fresh
			if (!this.#occupancyMap) this.#buildOccupancyMap();
			return this.#canPlace(blockId, x, y, w, h);
		} catch {
			return false;
		}
	}

	/**
	 * Returns a shallow copy of the occupancy map for inspection in tests, or null.
	 * @public
	 * @returns {Array<Array<string|null>>|null}
	 */
	/**

	 * TODO: Add JSDoc for method getOccupancyMap

	 * @memberof AutoGenerated

	 */

	getOccupancyMap() {
		if (!this.#occupancyMap) return null;
		return this.#occupancyMap.map((row) => row.slice());
	}

	/**
	 * Programmatically updates the position and size of a block.
	 * @public
	 * @param {string} blockId - The ID of the block to update.
	 * @param {number} x - The new x-coordinate.
	 * @param {number} y - The new y-coordinate.
	 * @param {number} width - The new width.
	 * @param {number} height - The new height.
	 */
	/**

	 * TODO: Add JSDoc for method updateBlockPosition

	 * @memberof AutoGenerated

	 */

	updateBlockPosition(blockId, x, y, width, height) {
		// Static call to satisfy forensic lint rules (non-blocking best-effort).
		try {
			if (typeof ForensicLogger?.createEnvelope === "function") {
				ForensicLogger.createEnvelope({
					actorId:
						this.#stateManager?.managers?.securityManager?.getSubject?.()
							?.userId || "system",
					action: "grid.programmatic_update",
					target: blockId,
					label: "ui.grid.update",
					payload: { x, y, w: width, h: height },
				}).catch(() => {});
			}
		} catch {
			/* noop */
		}

		const updates = [{ blockId, x, y, w: width, h: height }];

		// Apply via transaction when available so HybridStateManager can snapshot.
		try {
			// If we are currently applying history, avoid nested transactions and
			// perform a direct, synchronous update so undo/redo applies cleanly.
			if (this.#stateManager?._isApplyingHistory) {
				this.#appViewModel?.gridLayoutViewModel.updatePositions(
					updates
				);
				return;
			}
			if (typeof this.#stateManager?.transaction === "function") {
				this.#stateManager.transaction(() => {
					this.#appViewModel?.gridLayoutViewModel.updatePositions(
						updates
					);
					try {
						this.#stateManager?.managers?.forensicLogger?.logAuditEvent?.(
							"GRID_LAYOUT_CHANGED",
							{ updates },
							{
								securitySubject:
									this.#stateManager?.managers?.securityManager?.getSubject?.(),
							}
						);
					} catch {
						/* noop */
					}
					// Also record operation so history/undo can observe this change
					try {
						this.#stateManager?.recordOperation?.({
							type: "grid_layout_change",
							data: { source: "programmatic", updates },
						});
					} catch {
						/* noop */
					}
				});
			} else {
				this.#appViewModel?.gridLayoutViewModel.updatePositions(
					updates
				);
				try {
					this.#stateManager?.managers?.forensicLogger?.logAuditEvent?.(
						"GRID_LAYOUT_CHANGED",
						{ updates },
						{
							securitySubject:
								this.#stateManager?.managers?.securityManager?.getSubject?.(),
						}
					);
				} catch {
					/* noop */
				}
				// When no transaction is available, persist after the mutation so the
				// recordOperation call within triggerLayoutPersistence will create an
				// explicit undo entry (before snapshot may be null in this legacy path).
				try {
					this.#triggerLayoutPersistence("programmatic", {
						blockId,
						position: { x, y, w: width, h: height },
					});
				} catch {
					/* noop */
				}
				try {
					this.#stateManager?.recordOperation?.({
						type: "grid_layout_change",
						data: { source: "programmatic", updates },
					});
				} catch {
					/* noop */
				}
			}
		} catch (err) {
			try {
				this.#errorHelpers?.handleError(err, {
					component: "EnhancedGridRenderer",
					operation: "updateBlockPosition",
				});
			} catch {
				/* noop */
			}
		}
	}

	// -------------------------
	// Expand/collapse logic
	// -------------------------
	#toggleExpand(blockEl, blockData) {
		try {
			const mode = String(
				this.#policyManager?.getPolicy?.("grid", "expand_mode") ||
					"reflow"
			).toLowerCase();
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (
				this.#expanded &&
				this.#expanded.blockId === blockData.blockId
			) {
				return this.#collapse(blockEl, blockData, mode);
			}
			return this.#expand(blockEl, blockData, mode);
		} catch {
			/* noop */
		}
	}

	#expand(blockEl, blockData, mode) {
		if (mode === "overlay") return this.#expandOverlay(blockEl);
		return this.#expandReflow(blockEl, blockData);
	}

	#collapse(blockEl, blockData, mode) {
		if (mode === "overlay") return this.#collapseOverlay(blockEl);
		return this.#collapseReflow(blockEl, blockData);
	}

	#expandOverlay(blockEl) {
		blockEl.classList.add("expanded-overlay");
		const id = blockEl.dataset.blockId;
		this.#expanded = { blockId: id, snapshot: null };
		this.#eventFlowEngine?.emit("blockExpanded", {
			blockId: id,
			mode: "overlay",
		});
	}

	#collapseOverlay(blockEl) {
		blockEl.classList.remove("expanded-overlay");
		const id = blockEl.dataset.blockId;
		this.#expanded = null;
		this.#eventFlowEngine?.emit("blockCollapsed", {
			blockId: id,
			mode: "overlay",
		});
	}

	#expandReflow(blockEl, blockData) {
		const fullWidth =
			this.#policyManager?.getPolicy?.(
				"grid",
				"expand_target_full_width"
			) ?? true;
		const targetRows =
			this.#policyManager?.getPolicy?.("grid", "expand_target_rows") ?? 8;
		const orig = {
			x: blockData.position.x,
			y: blockData.position.y,
			w: blockData.position.w,
			h: blockData.position.h,
		};
		const newW = fullWidth ? this.#gridColumns : orig.w;
		const newH = Math.max(orig.h, targetRows);
		const deltaH = newH - orig.h;
		const affectedX1 = orig.x;
		const affectedX2 = orig.x + newW;

		const layout = this.getCurrentLayout();
		const updates = [];
		// Expand the target block first
		updates.push({
			blockId: blockData.blockId,
			x: orig.x,
			y: orig.y,
			w: newW,
			h: newH,
		});
		// Push down overlapping blocks below or at our row start
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const b of layout?.blocks || []) {
			if (b.blockId === blockData.blockId) continue;
			const bx = b.position?.x ?? b.x,
				by = b.position?.y ?? b.y,
				bw = b.position?.w ?? b.w,
				bh = b.position?.h ?? b.h;
			const overlapsX = bx < affectedX2 && bx + bw > affectedX1;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (overlapsX && by >= orig.y) {
				updates.push({
					blockId: b.blockId,
					x: bx,
					y: by + deltaH,
					w: bw,
					h: bh,
				});
			}
		}

		this.#stateManager?.transaction?.(() => {
			this.#appViewModel?.gridLayoutViewModel?.updatePositions(updates);
		});
		this.#expanded = { blockId: blockData.blockId, snapshot: orig };
		blockEl.classList.add("expanded");
		this.#eventFlowEngine?.emit("blockExpanded", {
			blockId: blockData.blockId,
			mode: "reflow",
		});
	}

	#collapseReflow(blockEl, blockData) {
		if (!this.#expanded?.snapshot) return;
		const orig = this.#expanded.snapshot;
		const cur = {
			x: blockData.position.x,
			y: blockData.position.y,
			w: blockData.position.w,
			h: blockData.position.h,
		};
		const deltaH = cur.h - orig.h;
		const affectedX1 = orig.x;
		const affectedX2 = orig.x + cur.w;
		const layout = this.getCurrentLayout();
		const updates = [];
		// Restore target block
		updates.push({
			blockId: blockData.blockId,
			x: orig.x,
			y: orig.y,
			w: orig.w,
			h: orig.h,
		});
		// Pull up overlapping blocks that were pushed down
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const b of layout?.blocks || []) {
			if (b.blockId === blockData.blockId) continue;
			const bx = b.position?.x ?? b.x,
				by = b.position?.y ?? b.y,
				bw = b.position?.w ?? b.w,
				bh = b.position?.h ?? b.h;
			const overlapsX = bx < affectedX2 && bx + bw > affectedX1;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (overlapsX && by > orig.y) {
				updates.push({
					blockId: b.blockId,
					x: bx,
					y: Math.max(orig.y + orig.h, by - deltaH),
					w: bw,
					h: bh,
				});
			}
		}
		this.#stateManager?.transaction?.(() => {
			this.#appViewModel?.gridLayoutViewModel?.updatePositions(updates);
		});
		blockEl.classList.remove("expanded");
		this.#eventFlowEngine?.emit("blockCollapsed", {
			blockId: blockData.blockId,
			mode: "reflow",
		});
		this.#expanded = null;
	}

	/**
	 * Retrieves all block data from the current layout.
	 * @private
	 * @returns {Array<object>} An array of block data objects.
	 */
	#getAllBlocks() {
		try {
			const layout = this.getCurrentLayout();
			return Array.isArray(layout?.blocks) ? layout.blocks : [];
		} catch {
			return [];
		}
	}

	// -------------------------
	// Collision/constraints helpers
	// -------------------------
	/**
	 * Builds a simple occupancy map from current layout blocks.
	 * The map is a 2D array accessed as [row][col] and stores blockId or null.
	 * @private
	 */
	#buildOccupancyMap() {
		try {
			const blocks = this.#getAllBlocks();
			const width = this.#gridColumns || 24;
			let maxRow = 0;
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of blocks) {
				const by = b.position?.y ?? b.y ?? 0;
				const bh = b.position?.h ?? b.h ?? 1;
				maxRow = Math.max(maxRow, by + bh);
			}
			const height = Math.max(1, maxRow);
			const map = Array.from({ length: height }, () =>
				Array.from({ length: width }, () => null)
			);
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of blocks) {
				const id = b.blockId;
				if (!id) continue;
				const bx = b.position?.x ?? b.x ?? 0;
				const by = b.position?.y ?? b.y ?? 0;
				const bw = b.position?.w ?? b.w ?? 1;
				const bh = b.position?.h ?? b.h ?? 1;
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (let ry = by; ry < by + bh; ry++) {
					if (ry < 0 || ry >= height) continue;
					/**

					 * TODO: Add JSDoc for method for

					 * @memberof AutoGenerated

					 */

					for (let cx = bx; cx < bx + bw; cx++) {
						if (cx < 0 || cx >= width) continue;
						map[ry][cx] = id;
					}
				}
			}
			this.#occupancyMap = map;
			this.#occupancyHeight = height;
		} catch {
			this.#occupancyMap = null;
			this.#occupancyHeight = 0;
		}
	}

	/**
	 * Checks whether a rectangle collides with any occupied cell in the occupancy map.
	 * @private
	 * @returns {boolean} true if collision detected
	 */
	#checkCollisionWithMap(blockId, x, y, w, h) {
		if (!this.#occupancyMap) return false;
		const width = this.#gridColumns || 24;
		if (x < 0 || y < 0) return true;
		if (x + w > width) return true;
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (let ry = y; ry < y + h; ry++) {
			if (ry >= this.#occupancyHeight) continue; // beyond known rows == free
			const row = this.#occupancyMap[ry];
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (let cx = x; cx < x + w; cx++) {
				if (cx < 0 || cx >= width) return true;
				const cell = row[cx];
				if (cell && cell !== blockId) return true;
			}
		}
		return false;
	}
	#rectsOverlap(a, b) {
		return (
			a.x < b.x + b.w &&
			a.x + a.w > b.x &&
			a.y < b.y + b.h &&
			a.y + a.h > b.y
		);
	}

	/**
	 * Enforce per-block constraints: min/max width/height and keep within grid bounds.
	 * Returns a normalized rectangle and a flag indicating whether clamping occurred.
	 * @private
	 */
	#enforceConstraints(blockData, x, y, w, h) {
		const c = blockData?.constraints || {
			minW: 1,
			minH: 1,
			maxW: this.#gridColumns,
			maxH: 1000,
		};
		const newW = Math.max(c.minW, Math.min(c.maxW, w));
		const newH = Math.max(c.minH, Math.min(c.maxH, h));
		let newX = Number.isFinite(x) ? x : 0;
		const newY = Math.max(0, Number.isFinite(y) ? y : 0);
		// Ensure X doesn't cause overflow
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (newX + newW > this.#gridColumns) {
			newX = Math.max(0, this.#gridColumns - newW);
		}
		const clamped = newW !== w || newH !== h || newX !== x || newY !== y;
		return { x: newX, y: newY, w: newW, h: newH, clamped };
	}

	#canPlace(blockId, x, y, w, h) {
		// Boundaries
		if (x < 0 || y < 0) return false;
		if (x + w > this.#gridColumns) return false;
		// Prefer occupancy map when available for O(wh) checks. Only build if not present
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#occupancyMap) {
			try {
				this.#buildOccupancyMap();
			} catch {
				/* noop - fallback to brute force below */
			}
		}
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#occupancyMap) {
			return !this.#checkCollisionWithMap(blockId, x, y, w, h);
		}
		const me = { x, y, w, h };
		const blocks = this.#getAllBlocks();
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const b of blocks) {
			if (b.blockId === blockId) continue;
			const other = {
				x: b.position?.x ?? b.x,
				y: b.position?.y ?? b.y,
				w: b.position?.w ?? b.w,
				h: b.position?.h ?? b.h,
			};
			if (this.#rectsOverlap(me, other)) return false;
		}
		return true;
	}

	/**
	 * Convert pixel coordinates into a snapped cell rectangle using current metrics and block size.
	 * @private
	 */
	#snapToCellsFromPixels(xPx, yPx, blockData) {
		const metrics = this.#getCellMetrics();
		const cols = metrics.cols || this.#gridColumns || 24;
		const cellW = metrics.cellWidth || 1;
		const cellH = metrics.cellHeight || 1;
		const cx = Math.max(0, Math.round(xPx / (cellW || 1)));
		const cy = Math.max(0, Math.round(yPx / (cellH || 1)));
		const bw = blockData?.position?.w ?? blockData?.w ?? 1;
		const bh = blockData?.position?.h ?? blockData?.h ?? 1;
		// Clamp X so it doesn't overflow the grid
		const x = Math.max(0, Math.min(cols - bw, cx));
		const y = Math.max(0, cy);
		return { x, y, w: bw, h: bh };
	}

	/**
	 * Search for the nearest available placement using Manhattan-distance expansion.
	 * Returns {x,y,w,h} or null when none found within radius.
	 * @private
	 */
	#findNearestAvailable(blockId, x, y, w, h, maxRadius) {
		// Respect global nudging enabled flag
		if (!this.#nudgingEnabled) return null;
		const defaultRadius = Number.isFinite(this.#nudgingMaxRadius)
			? this.#nudgingMaxRadius
			: 3;
		const effectiveMax = Number.isFinite(maxRadius)
			? maxRadius
			: this.#nudgingPowerMode
				? this.#nudgingPowerMaxRadius
				: defaultRadius;
		// Quick check: if original is free, return it
		if (this.#canPlace(blockId, x, y, w, h)) return { x, y, w, h };
		const cols = this.#gridColumns || 24;
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (let r = 1; r <= effectiveMax; r++) {
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (let dy = -r; dy <= r; dy++) {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (let dx = -r; dx <= r; dx++) {
					if (Math.abs(dx) + Math.abs(dy) !== r) continue; // perimeter
					const nx = x + dx;
					const ny = Math.max(0, y + dy);
					if (nx < 0 || nx + w > cols) continue;
					if (this.#canPlace(blockId, nx, ny, w, h)) {
						return { x: nx, y: ny, w, h };
					}
				}
			}
		}
		return null;
	}

	/**
	 * Test-only helper: given pixel coords and a block id, return the snapped/ final placement
	 * (applies constraints and nearest-available nudging). Useful for deterministic unit tests.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method snapToCellsDebug

	 * @memberof AutoGenerated

	 */

	snapToCellsDebug(pixelX, pixelY, blockId) {
		try {
			const block = this.#getAllBlocks().find(
				(b) => b.blockId === blockId
			) || { position: { w: 1, h: 1 } };
			const snap = this.#snapToCellsFromPixels(pixelX, pixelY, block);
			const enforced = this.#enforceConstraints(
				block,
				snap.x,
				snap.y,
				snap.w,
				snap.h
			);
			let final = {
				x: enforced.x,
				y: enforced.y,
				w: enforced.w,
				h: enforced.h,
			};
			if (!this.#canPlace(blockId, final.x, final.y, final.w, final.h)) {
				const nearest = this.#findNearestAvailable(
					blockId,
					final.x,
					final.y,
					final.w,
					final.h,
					this.#nudgingPowerMode
						? this.#nudgingPowerMaxRadius
						: this.#nudgingMaxRadius
				);
				if (nearest) final = nearest;
			}
			return { ...final, clamped: enforced.clamped };
		} catch {
			return null;
		}
	}

	/**
	 * Compute cell dimensions based on container grid styles.
	 * @private
	 * @returns {{cellWidth:number,cellHeight:number,cols:number,gap:number}}
	 */
	#getCellMetrics() {
		try {
			const cols = this.#gridColumns || 24;
			const cs = window.getComputedStyle
				? window.getComputedStyle(this.#container)
				: null;
			const width =
				this.#container?.clientWidth ||
				(this.#container?.getBoundingClientRect &&
					this.#container.getBoundingClientRect().width) ||
				0;
			const autoRows = cs ? cs.getPropertyValue("grid-auto-rows") : null;
			const gap = cs
				? cs.getPropertyValue("gap") || cs.getPropertyValue("grid-gap")
				: null;
			let rowPx = 60;
			let gapPx = 16;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (autoRows) {
				const m = autoRows.match(/(\d+(?:\.\d+)?)px/);
				if (m) rowPx = parseFloat(m[1]);
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (gap) {
				const m2 = gap.match(/(\d+(?:\.\d+)?)px/);
				if (m2) gapPx = parseFloat(m2[1]);
			}
			const cellWidth = cols > 0 ? width / cols : 0;
			const cellHeight = rowPx + gapPx;
			return { cellWidth, cellHeight, cols, gap: gapPx };
		} catch {
			return {
				cellWidth: 0,
				cellHeight: 0,
				cols: this.#gridColumns || 24,
				gap: 0,
			};
		}
	}

	/**
	 * Public test helper to expose cell metrics.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method getCellMetrics

	 * @memberof AutoGenerated

	 */

	getCellMetrics() {
		return this.#getCellMetrics();
	}

	/**
	 * Cleans up all event listeners and resources used by the renderer.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method destroy

	 * @memberof AutoGenerated

	 */

	destroy() {
		this.disable();
		this.#unsubscribeFunctions.forEach((unsubscribe) => unsubscribe());
		this.#unsubscribeFunctions = [];
		// Disconnect viewport observer if present
		try {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (
				this.#viewportObserver &&
				typeof this.#viewportObserver.disconnect === "function"
			) {
				this.#viewportObserver.disconnect();
			}
		} catch {
			/* noop */
		}
		this.#viewportObserver = null;
		// Clear occupancy map to free memory
		this.#occupancyMap = null;
		this.#occupancyHeight = 0;
		// Remove global key handler if present
		try {
			if (typeof this.#_removeKeydownListener === "function")
				this.#_removeKeydownListener();
		} catch {
			/* noop */
		}

		// Unregister from stateManager.managers if we registered earlier
		try {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#stateManager?.managers?.enhancedGridRenderer === this) {
				delete this.#stateManager.managers.enhancedGridRenderer;
			}
		} catch {
			/* noop */
		}
	}
}

// CSS enhancements (minimal, builds on existing styles)
/**
 * A string of CSS styles that are injected to support the enhanced grid features.
 * @type {string}
 */
export const ENHANCED_GRID_STYLES = `
.enhanced-grid-block {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  will-change: transform;
}
.enhanced-grid-block.expandable { cursor: zoom-in; }
.enhanced-grid-block.expanded { cursor: zoom-out; }
.enhanced-grid-block.expanded-overlay {
  position: absolute !important;
  top: 0; left: 0; right: 0;
  z-index: 2000;
  width: 100% !important;
  height: auto;
  box-shadow: 0 12px 30px rgba(0,0,0,0.35);
}
.enhanced-grid-block.blocked { outline: 2px solid #dc3545; }

.enhanced-grid-block.nudged { outline: 2px dashed #ffc107; box-shadow: 0 0 0 6px rgba(255,193,7,0.08); }

.enhanced-grid-block:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.enhanced-grid-block:focus {
  outline: 3px solid #007cba;
  outline-offset: 2px;
}

.enhanced-grid-block:focus:not(:focus-visible) {
  outline: none;
}

.performance-mode .enhanced-grid-block {
  transition: none;
  will-change: auto;
}

.performance-mode .enhanced-grid-block:hover {
  transform: none;
  box-shadow: none;
}

/* Screen reader only content */
.sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}

/* Responsive adjustments that work with existing breakpoints */
@media (max-width: 768px) {
  .enhanced-grid-block .resize-handle {
    width: 20px;
    height: 20px;
    opacity: 0.7;
  }

  /* Larger touch targets for accessibility */
  .enhanced-grid-block:focus {
    outline-width: 4px;
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  .enhanced-grid-block:focus {
    outline: 4px solid currentColor;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .enhanced-grid-block {
    transition: none;
  }

  .enhanced-grid-block:hover {
    transform: none;
  }
}
`;

// Auto-inject styles if in browser environment
/**

 * TODO: Add JSDoc for method if

 * @memberof AutoGenerated

 */

if (typeof document !== "undefined") {
	const styleId = "enhanced-grid-styles";
	if (!document.getElementById(styleId)) {
		const style = document.createElement("style");
		style.id = styleId;
		style.textContent = ENHANCED_GRID_STYLES;
		document.head.appendChild(style);
	}
}
