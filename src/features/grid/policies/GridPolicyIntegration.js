/**
 * @file GridPolicyIntegration.js
 * @description Lightweight policy service that lazy-loads grid policy definitions/validators via dynamic import.
 */

/**
 * @class GridPolicyService
 * @classdesc Managed service for accessing and managing grid-specific policies. Lazily registers definitions.
 * @privateFields {#policyManager, #cache}
 */
export class GridPolicyService {
	/** @private @type {import('../platform/security/SystemPoliciesCached.js').SystemPolicies} */
	#policyManager;
	/** @private @type {import('../../../platform/services/cache/CacheManager.js').LRUCache} */
	#cache;
	#tenantPolicy;
	#tenantOverrides = {};
	#nestingLoaded = false;

	/**
	 * Creates an instance of GridPolicyService.
	 * @param {object} context - The context object from the ServiceRegistry.
	 * @param {import('../core/HybridStateManager.js').default} context.stateManager - The application's state manager.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager }) {
		this.#policyManager = stateManager.managers.policies;
		this.#tenantPolicy = stateManager.managers.tenantPolicyService;

		// Mandate 4.1: Use a bounded cache from the central CacheManager.
		this.#cache = stateManager.managers.cacheManager.getCache(
			"gridPolicies",
			{
				max: 10, // Cache up to 10 policy sets/keys
				ttl: 30000, // 30-second TTL
			}
		);
	}

	/**
	 * Registers the grid-specific policies, validators, and dependencies with the main SystemPolicies manager.
	 * This is the V8 Parity-compliant replacement for the old `extendSystemPoliciesWithGrid` function.
	 * @returns {void}
	 */
	/**
	 * Lazy-registers grid policies. Pass options to include only modules you need.
	 * @param {{ includeNesting?: boolean }} [options]
	 */
	/**

	 * TODO: Add JSDoc for method registerGridPolicies

	 * @memberof AutoGenerated

	 */

	async registerGridPolicies(options = {}) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#policyManager) {
			console.warn(
				"[GridPolicyService] Cannot register policies, SystemPolicies manager not found."
			);
			return;
		}

		// Lazy-load definitions/validators to keep initial bundle small
		try {
			// Prefer the cleaned policy module if present (safe migration path)
			// Use the canonical core policy module
			const core = await import(
				"@platform/security/policies/grid/CoreGridPolicy.js"
			);
			this.#policyManager.registerPolicyDefinitions({
				...core.CORE_GRID_POLICY_DEFINITIONS,
			});
			this.#policyManager.registerPolicyValidators({
				...core.CORE_GRID_POLICY_VALIDATORS,
			});
			// Register presets if the SystemPolicies manager supports them
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (
				typeof this.#policyManager.registerPolicyPresets ===
					"function" &&
				core.CORE_GRID_POLICY_PRESETS
			) {
				try {
					this.#policyManager.registerPolicyPresets(
						core.CORE_GRID_POLICY_PRESETS
					);
				} catch {
					// Non-fatal: presets are convenience data
				}
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (options.includeNesting) {
				const nesting = await import(
					"@platform/security/policies/grid/NestingPolicy.js"
				);
				this.#policyManager.registerPolicyDefinitions({
					...nesting.NESTING_POLICY_DEFINITIONS,
				});
				this.#policyManager.registerPolicyValidators({
					...nesting.NESTING_POLICY_VALIDATORS,
				});
				this.#nestingLoaded = true;
			}

			// Prime tenant overrides for keys we care about so getters can be sync-friendly
			await this.#primeTenantOverrides(options);
		} catch (e) {
			console.warn(
				"[GridPolicyService] Failed to load policy modules:",
				e
			);
		}
	}

	/**


	 * TODO: Add JSDoc for method ensureNestingPoliciesLoaded


	 * @memberof AutoGenerated


	 */

	async ensureNestingPoliciesLoaded() {
		if (this.#nestingLoaded) return;
		await this.registerGridPolicies({ includeNesting: true });
	}

	async #primeTenantOverrides(options) {
		try {
			if (!this.#tenantPolicy?.getPolicy) return;
			const keys = [
				["system", "grid_performance_mode"],
				["system", "grid_auto_save_layouts"],
				["system", "grid_save_feedback"],
				["system", "grid_ai_suggestions"],
				["grid", "default_columns"],
				["grid", "default_min_w"],
				["grid", "default_min_h"],
				["grid", "default_max_w"],
				["grid", "default_max_h"],
				["grid", "allowed_component_types"],
				// Nudging UX policies (non-critical, tenant-overridable)
				["grid", "nudging_enabled"],
				["grid", "nudging_max_radius"],
				["grid", "nudging_prefer"],
				["grid", "nudging_tooltip_enabled"],
				["grid", "nudging_tooltip_duration"],
				["grid", "nudging_power_mode"],
				["grid", "nudging_power_max_radius"],
			];
			const canonicalKeys = Object.keys(
				CORE_GRID_POLICY_DEFINITIONS
			)
				.filter((path) => path.includes("grid."))
				.map((path) => path.split("."));
			for (const pair of canonicalKeys) {
				if (!keys.some(([d, k]) => d === pair[0] && k === pair[1])) {
					keys.push(pair);
				}
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (options.includeNesting) {
				keys.push(
					["grid", "nesting_enabled"],
					["grid", "nesting_max_depth"],
					["grid", "nesting_max_blocks_per_grid"],
					["grid", "nesting_max_total_blocks"]
				);
				for (const pair of Object.keys(NESTING_POLICY_DEFINITIONS).map((path) =>
					path.split(".")
				)) {
					if (!keys.some(([d, k]) => d === pair[0] && k === pair[1])) {
						keys.push(pair);
					}
				}
			}
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const [d, k] of keys) {
				try {
					const ov = await this.#tenantPolicy.getPolicy(d, k);
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (ov !== undefined) {
						this.#tenantOverrides[`${d}.${k}`] = ov;
					}
				} catch {
					/* noop */
				}
			}
		} catch {
			/* noop */
		}
	}

	#getTenantOr(baseDomain, baseKey, baseValue) {
		const ov = this.#tenantOverrides?.[`${baseDomain}.${baseKey}`];
		return ov !== undefined ? ov : baseValue;
	}

	/**
	 * Gets the grid performance mode policy.
	 * The policy can be `true` (force on), `false` (force off), or `null` (automatic).
	 * @returns {boolean|null} The current performance mode policy.
	 */
	/**

	 * TODO: Add JSDoc for method getPerformanceMode

	 * @memberof AutoGenerated

	 */

	getPerformanceMode() {
		try {
			const base = this.#policyManager.getPolicy(
				"system",
				"grid_performance_mode"
			);
			return this.#getTenantOr("system", "grid_performance_mode", base);
		} catch (error) {
			console.warn("Could not get grid performance policy:", error);
			return null; // Default to auto mode
		}
	}

	/**
	 * Checks if the auto-save layout policy is enabled.
	 * @returns {boolean} `true` if auto-save is enabled, `false` otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method isAutoSaveEnabled

	 * @memberof AutoGenerated

	 */

	isAutoSaveEnabled() {
		try {
			const base = this.#policyManager.getPolicy(
				"system",
				"grid_auto_save_layouts"
			);
			const v = this.#getTenantOr(
				"system",
				"grid_auto_save_layouts",
				base
			);
			return v ?? true;
		} catch (error) {
			console.warn("Could not get grid auto-save policy:", error);
			return true; // Default to enabled
		}
	}

	/**
	 * Checks if the policy for showing save feedback (toasts) is enabled.
	 * @returns {boolean} `true` if save feedback should be shown, `false` otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method shouldShowSaveFeedback

	 * @memberof AutoGenerated

	 */

	shouldShowSaveFeedback() {
		try {
			const base = this.#policyManager.getPolicy(
				"system",
				"grid_save_feedback"
			);
			const v = this.#getTenantOr("system", "grid_save_feedback", base);
			return v ?? true;
		} catch (error) {
			console.warn("Could not get grid save feedback policy:", error);
			return true; // Default to enabled
		}
	}

	/**
	 * Checks if the policy for AI-powered layout suggestions is enabled.
	 * @returns {boolean} `true` if AI suggestions are enabled, `false` otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method isAiSuggestionsEnabled

	 * @memberof AutoGenerated

	 */

	isAiSuggestionsEnabled() {
		try {
			const base = this.#policyManager.getPolicy(
				"system",
				"grid_ai_suggestions"
			);
			const v = this.#getTenantOr("system", "grid_ai_suggestions", base);
			return v ?? false;
		} catch (error) {
			console.warn("Could not get grid AI suggestions policy:", error);
			return false; // Default to disabled
		}
	}

	/**
	 * Sets the grid performance mode policy and emits an event to notify the system of the change.
	 * @param {boolean|null} mode - The new mode (`true` for on, `false` for off, `null` for auto).
	 * @returns {Promise<boolean>} `true` if the policy was set successfully, `false` otherwise.
	 */
	/**

	 * TODO: Add JSDoc for method setPerformanceMode

	 * @memberof AutoGenerated

	 */

	async setPerformanceMode(mode) {
		try {
			await this.#policyManager.setPolicy(
				"system",
				"grid_performance_mode",
				mode
			);

			// Clear cache to force refresh
			this.clearCache();

			// Event is emitted by SystemPolicies automatically, no need to re-emit.
			return true;
		} catch (error) {
			console.error("Failed to set grid performance mode:", error);
			return false;
		}
	}

	/**
	 * Gets an object containing all grid-related policies, using a bounded LRU cache for performance.
	 * @returns {{performanceMode: boolean|null, autoSave: boolean, saveFeedback: boolean, aiSuggestions: boolean}}
	 * An object with the current state of all grid policies.
	 */
	/**

	 * TODO: Add JSDoc for method getGridPolicies

	 * @memberof AutoGenerated

	 */

	getGridPolicies() {
		const cacheKey = "grid_policies";
		const cachedPolicies = this.#cache.get(cacheKey);

		// Check cache first
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (cachedPolicies) {
			return cachedPolicies;
		}

		try {
			const policies = {
				performanceMode: this.getPerformanceMode(),
				autoSave: this.isAutoSaveEnabled(),
				saveFeedback: this.shouldShowSaveFeedback(),
				aiSuggestions: this.isAiSuggestionsEnabled(),
				// Nudging UX defaults (tenant-aware)
				nudging: this.getNudgingConfig(),
			};

			// Cache the result
			this.#cache.set(cacheKey, policies);

			return policies;
		} catch (error) {
			console.warn("Could not get grid policies:", error);

			return {
				performanceMode: null,
				autoSave: true,
				saveFeedback: true,
				aiSuggestions: false,
				nudging: {
					enabled: true,
					maxRadius: 3,
					prefer: ["right", "down", "left", "up"],
					tooltipEnabled: true,
					tooltipDuration: 1200,
					powerMode: false,
					powerMaxRadius: 8,
				},
			};
		}
	}

	/**
	 * Returns tenant-aware nudging configuration. Uses tenant overrides when present.
	 * @returns {{enabled:boolean,maxRadius:number,prefer:string[],tooltipEnabled:boolean,tooltipDuration:number,powerMode:boolean,powerMaxRadius:number}}
	 */
	/**

	 * TODO: Add JSDoc for method getNudgingConfig

	 * @memberof AutoGenerated

	 */

	getNudgingConfig() {
		try {
			const baseEnabled = this.#policyManager.getPolicy(
				"grid",
				"nudging_enabled"
			);
			const enabled = this.#getTenantOr(
				"grid",
				"nudging_enabled",
				baseEnabled
			);

			const baseMax = this.#policyManager.getPolicy(
				"grid",
				"nudging_max_radius"
			);
			const maxRadius = Number.isFinite(Number(baseMax))
				? Math.max(0, Number(baseMax))
				: 3;
			const max = this.#getTenantOr(
				"grid",
				"nudging_max_radius",
				maxRadius
			);

			const pref = this.#getTenantOr(
				"grid",
				"nudging_prefer",
				this.#policyManager.getPolicy("grid", "nudging_prefer") || [
					"right",
					"down",
					"left",
					"up",
				]
			);

			const tip = this.#getTenantOr(
				"grid",
				"nudging_tooltip_enabled",
				this.#policyManager.getPolicy("grid", "nudging_tooltip_enabled")
			);
			const tipDurBase = this.#policyManager.getPolicy(
				"grid",
				"nudging_tooltip_duration"
			);
			const tipDur = Number.isFinite(Number(tipDurBase))
				? Math.max(200, Number(tipDurBase))
				: 1200;
			const tipDurFinal = this.#getTenantOr(
				"grid",
				"nudging_tooltip_duration",
				tipDur
			);

			const power = this.#getTenantOr(
				"grid",
				"nudging_power_mode",
				this.#policyManager.getPolicy("grid", "nudging_power_mode")
			);
			const pMaxBase = this.#policyManager.getPolicy(
				"grid",
				"nudging_power_max_radius"
			);
			const pMax = Number.isFinite(Number(pMaxBase))
				? Math.max(max, Number(pMaxBase))
				: 8;
			const pMaxFinal = this.#getTenantOr(
				"grid",
				"nudging_power_max_radius",
				pMax
			);

			return {
				enabled: enabled !== false,
				maxRadius: Number(max),
				prefer: Array.isArray(pref)
					? pref
					: ["right", "down", "left", "up"],
				tooltipEnabled: tip !== false,
				tooltipDuration: Number(tipDurFinal),
				powerMode: power === true,
				powerMaxRadius: Number(pMaxFinal),
			};
		} catch (e) {
			console.warn(
				"[GridPolicyService] could not read nudging config",
				e
			);
			return {
				enabled: true,
				maxRadius: 3,
				prefer: ["right", "down", "left", "up"],
				tooltipEnabled: true,
				tooltipDuration: 1200,
				powerMode: false,
				powerMaxRadius: 8,
			};
		}
	}

	/**
	 * Clears the local cache for grid-specific policies.
	 */
	/**

	 * TODO: Add JSDoc for method clearCache

	 * @memberof AutoGenerated

	 */

	clearCache() {
		this.#cache.clear();
	}

	/**
	 * Sets a per-tenant override for a grid-related policy.
	 * @param {string} domain
	 * @param {string} key
	 * @param {*} value
	 */
	/**

	 * TODO: Add JSDoc for method setTenantPolicy

	 * @memberof AutoGenerated

	 */

	async setTenantPolicy(domain, key, value) {
		if (!this.#tenantPolicy?.setPolicy)
			throw new Error("Tenant policy service unavailable");
		const ok = await this.#tenantPolicy.setPolicy(domain, key, value);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (ok) {
			this.#tenantOverrides[`${domain}.${key}`] = value;
			this.clearCache();
		}
		return ok;
	}
}

/**
 * Renaming the default export for clarity and to avoid confusion with the old static helper.
 * The class itself is the primary export.
 */
export default GridPolicyService;
