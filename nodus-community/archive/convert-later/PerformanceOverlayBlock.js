import { ForensicLogger } from "@core/security/ForensicLogger.js";
// ui/blocks/PerformanceOverlayBlock.js
// Composable performance monitoring building block

/**
 * Performance Overlay BuildingBlock
 * Real-time metrics visualization as a composable component
 * @class PerformanceOverlayBlock
 * @description A class-based BuildingBlock that renders a real-time performance monitoring overlay.
 * It visualizes key metrics from various system components like the state manager, database, and renderer.
 * This class adheres to the project's private field and encapsulation mandates.
 * @privateFields {#context, #config, #theme, #container, #titleElement, #metricsContainer, #updateInterval, #isActive, #metrics}
 */
class PerformanceOverlayBlock_V2 {
	#context;
	#config;
	#theme;
	#container;
	#titleElement;
	#metricsContainer;
	#updateInterval = null;
	#isActive = true;
	#metrics;

	/**
	 * @constructor
	 * @param {object} params - The parameters for rendering the block.
	 * @param {import('../../core/RenderContext.js').RenderContext} params.context - The rendering context.
	 * @param {object} [params.config={}] - Configuration options for the block.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

		constructor({ context, config = {} }) {
		this.#context = context;
		this.#config = config;
		this.#theme = this.#context.getThemeVariables();
		this.#metrics = this.#context.metricsRegistry;

		this.#container = document.createElement("div");
		this.#container.className = "performance-overlay-block";

		this.#applyStyling();
		this.#createDOM();

		this.#setupEventListeners();
		this.#setupCleanupObserver();

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

				if (this.#config.autoStart !== false) {
			requestAnimationFrame(() => this.start());
		}
	}

	/**
	 * Applies CSS styling to the main container element.
	 * @private
	 */
	#applyStyling() {
		this.#container.style.cssText = `
    padding: ${this.#config.padding || "1rem"};
    border-radius: ${this.#config.borderRadius || "8px"};
    background: ${this.#config.background || this.#theme["--surface-elevated"]};
    color: ${this.#config.color || this.#theme["--text"]};
    font-family: 'Courier New', monospace;
    font-size: ${this.#config.fontSize || "12px"};
    border: 1px solid ${this.#theme["--border"]};
    min-width: ${this.#config.minWidth || "250px"};
    max-height: ${this.#config.maxHeight || "400px"};
    overflow-y: auto;
    position: ${this.#config.position || "relative"};
    transition: opacity 0.3s ease-in-out;
  `;

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

				if (this.#config.overlay) {
			this.#container.style.position = "fixed";
			this.#container.style.bottom = this.#config.bottom || "10px";
			this.#container.style.right = this.#config.right || "10px";
			this.#container.style.zIndex = this.#config.zIndex || "9999";
			this.#container.style.background =
				this.#config.overlayBackground || "rgba(0,0,0,0.85)";
		}
	}

	/**
	 * Creates the initial DOM structure for the block.
	 * @private
	 */
	#createDOM() {
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		this.#titleElement = document.createElement("h4");
		this.#titleElement.textContent =
			this.#config.title || "System Performance";
		this.#titleElement.style.cssText = `
    margin: 0 0 0.75rem 0;
    color: ${this.#theme["--primary"]};
    font-size: 14px;
    font-weight: bold;
  `;
		this.#container.appendChild(this.#titleElement);

		this.#metricsContainer = document.createElement("div");
		this.#metricsContainer.className = "metrics-container";
		this.#container.appendChild(this.#metricsContainer);
	}

	/**
	 * @function formatMetrics
	 * @description Formats a raw metrics object into a structured array of sections suitable for display.
	 * @private
	 * @param {object} metrics - The raw metrics object gathered from various system components.
	 * @returns {Array<{title: string, items: Array<{label: string, value: any, unit: string}>}>} An array of formatted metric sections.
	 */
	#formatMetrics(metrics) {
		const sections = [];

		// System Load Section
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (metrics.system) {
			sections.push({
				title: "System Load",
				items: [
					{
						label: "Entities",
						value: metrics.system.entityCount || 0,
						unit: "",
					},
					{
						label: "Memory",
						value: this.#formatBytes(
							metrics.system.memoryUsage || 0
						),
						unit: "",
					},
					{
						label: "Cache Hit Rate",
						value: (metrics.system.cacheHitRate || 0).toFixed(1),
						unit: "%",
					},
				],
			});
		}

		// Database Performance
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (metrics.database) {
			sections.push({
				title: "Database",
				items: [
					{
						label: "Avg Query Time",
						value: (metrics.database.avgQueryTime || 0).toFixed(2),
						unit: "ms",
					},
					{
						label: "Active Queries",
						value: metrics.database.activeQueries || 0,
						unit: "",
					},
					{
						label: "Optimization Score",
						value: (
							metrics.database.optimizationScore || 0
						).toFixed(1),
						unit: "/10",
					},
				],
			});
		}

		// Rendering Performance
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (metrics.rendering) {
			sections.push({
				title: "Rendering",
				items: [
					{
						label: "Avg Render Time",
						value: (
							metrics.rendering.averageRenderTime || 0
						).toFixed(2),
						unit: "ms",
					},
					{
						label: "Components",
						value: metrics.rendering.activeComponents || 0,
						unit: "",
					},
					{
						label: "Cache Hits",
						value: metrics.rendering.cacheHits || 0,
						unit: "",
					},
				],
			});
		}

		// State Manager
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (metrics.state) {
			sections.push({
				title: "State Manager",
				items: [
					{
						label: "Undo Stack",
						value: metrics.state.undoStackSize || 0,
						unit: "",
					},
					{
						label: "Pending Ops",
						value: metrics.state.pendingOperations || 0,
						unit: "",
					},
					{
						label: "Offline Ops",
						value: metrics.state.offlineOperations || 0,
						unit: "",
					},
				],
			});
		}

		// Network & Connectivity
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (metrics.network) {
			sections.push({
				title: "Network",
				items: [
					{
						label: "Latency",
						value: (metrics.network.latency || 0).toFixed(0),
						unit: "ms",
					},
					{
						label: "Connection",
						value: metrics.network.type || "N/A",
						unit: "",
					},
					{
						label: "Online",
						value: metrics.network.online ? "Yes" : "No",
						unit: "",
					},
				],
			});
		}

		return sections;
	}

	/**
	 * @function formatBytes
	 * @description Converts a number of bytes into a human-readable string (e.g., KB, MB).
	 * @private
	 * @param {number} bytes - The number of bytes to format.
	 * @returns {string} The formatted string.
	 */
	#formatBytes(bytes) {
		if (bytes === 0) return "0 B";
		const k = 1024;
		const sizes = ["B", "KB", "MB", "GB"];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
	}

	/**
	 * @function createMetricSection
	 * @description Creates the DOM structure for a single section of metrics.
	 * @private
	 * @param {object} section - A formatted metric section object from `formatMetrics`.
	 * @returns {HTMLElement} The DOM element for the metric section.
	 */
	#createMetricSection(section) {
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		const sectionDiv = document.createElement("div");
		sectionDiv.className = "metric-section";
		sectionDiv.style.cssText = `
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid ${this.#theme["--border"]};
    `;

		// Section title
		const sectionTitle = document.createElement("div");
		sectionTitle.textContent = section.title;
		sectionTitle.style.cssText = `
      font-weight: bold;
      color: ${this.#theme["--text"]};
      margin-bottom: 0.25rem;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    `;
		sectionDiv.appendChild(sectionTitle);

		// Section items
		section.items.forEach((item) => {
			const itemDiv = document.createElement("div");
			itemDiv.style.cssText = `
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.125rem;
        font-size: 11px;
      `;

			const label = document.createElement("span");
			label.textContent = item.label + ":";
			label.style.color = this.#theme["--text-muted"];

			const value = document.createElement("span");
			value.textContent = item.value + (item.unit || "");
			value.style.cssText = `
        color: ${this.#getValueColor(item.label, item.value)};
        font-weight: bold;
      `;

			itemDiv.appendChild(label);
			itemDiv.appendChild(value);
			sectionDiv.appendChild(itemDiv);
		});

		return sectionDiv;
	}

	/**
	 * @function getValueColor
	 * @description Determines the appropriate color for a metric value based on its label and magnitude,
	 * indicating good, warning, or error states.
	 * @private
	 * @param {string} label - The label of the metric.
	 * @param {string|number} value - The value of the metric.
	 * @returns {string} A CSS color string.
	 */
	#getValueColor(label, value) {
		const numValue = parseFloat(value);

		if (label.includes("Error") || label.includes("Failed")) {
			return numValue > 0
				? this.#theme["--error"]
				: this.#theme["--success"];
		}

		if (label.includes("Time") || label.includes("Latency")) {
			if (numValue > 100) return this.#theme["--error"];
			if (numValue > 50) return this.#theme["--warning"];
			return this.#theme["--success"];
		}

		if (label.includes("Hit Rate") || label.includes("Score")) {
			if (numValue > 80) return this.#theme["--success"];
			if (numValue > 60) return this.#theme["--warning"];
			return this.#theme["--error"];
		}

		return this.#theme["--text"];
	}

	/**
	 * @function updateMetrics
	 * @description Gathers the latest metrics from all available sources and re-renders the block's content.
	 * @private
	 * @returns {void}
	 */
	#updateMetrics() {
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		if (!this.#isActive) return;

		const startTime = performance.now();

		try {
			// Get metrics from various sources
			const metrics = this.#gatherMetrics();

			// Clear previous content
			this.#metricsContainer.textContent = "";

			// Format and display metrics
			const sections = this.#formatMetrics(metrics);
			sections.forEach((section) => {
				this.#metricsContainer.appendChild(
					this.#createMetricSection(section)
				);
			});

			// Add timestamp
			const timestamp = document.createElement("div");
			timestamp.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
			timestamp.style.cssText = `
        font-size: 10px;
        color: ${this.#theme["--text-muted"]};
        text-align: right;
        margin-top: 0.5rem;
        opacity: 0.7;
      `;
			this.#metricsContainer.appendChild(timestamp);

			// Mandate 4.3: Report metrics on the overlay's own performance
			const duration = performance.now() - startTime;
			this.#metrics?.timer("performance_overlay.render", duration);
		} catch (error) {
			console.error("PerformanceOverlayBlock: Update error:", error);

			// Show error state
			this.#metricsContainer.textContent = "";
			const errorDiv = document.createElement("div");
			errorDiv.style.cssText = `color: ${this.#theme["--error"]}; font-size: 11px;`;
			errorDiv.textContent = `⚠️ Error loading metrics: ${error.message}`;
			this.#metricsContainer.appendChild(errorDiv);
		}
	}

	/**
	 * @function gatherMetrics
	 * @description Collects metrics from various system components available in the render context.
	 * @private
	 * @returns {object} A comprehensive metrics object.
	 */
	#gatherMetrics() {
		const metrics = {};

		// State Manager metrics
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (
			this.#context.stateManager &&
			typeof this.#context.stateManager.getPerformanceMetrics ===
				"function"
		) {
			const stateMetrics =
				this.#context.stateManager.getPerformanceMetrics();
			metrics.system = {
				entityCount: stateMetrics.entityCount || 0,
				memoryUsage: stateMetrics.memoryUsage || 0,
				cacheHitRate: stateMetrics.cacheHitRate || 0,
			};
			metrics.state = {
				undoStackSize: stateMetrics.undoStackSize || 0,
				pendingOperations: stateMetrics.pendingOperations || 0,
				offlineOperations: stateMetrics.offlineOperations || 0,
			};
			metrics.rendering = stateMetrics.rendering || {};
		}

		// Database metrics (if available)
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (
			this.#context.databaseOptimizer &&
			typeof this.#context.databaseOptimizer.getPerformanceMetrics ===
				"function"
		) {
			metrics.database =
				this.#context.databaseOptimizer.getPerformanceMetrics();
		}

		// Network metrics
		metrics.network = {
			online: navigator.onLine,
			type: navigator.connection?.effectiveType,
			latency: this.#context.networkLatency || 0,
		};

		// Browser performance metrics
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (performance.memory) {
			metrics.browser = {
				heapUsed: performance.memory.usedJSHeapSize,
				heapTotal: performance.memory.totalJSHeapSize,
				heapLimit: performance.memory.jsHeapSizeLimit,
			};
		}

		return metrics;
	}

	/**
	 * @description Starts the periodic interval for updating the metrics display.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method start

	 * @memberof AutoGenerated

	 */

		start() {
		if (this.#updateInterval) return;
		this.#isActive = true;

		const refreshRate = this.#config.refreshRate || 2000; // Default 2 seconds
		this.#updateInterval = setInterval(
			() => this.#updateMetrics(),
			refreshRate
		);
		this.#container.style.opacity = "1";
		this.#titleElement.textContent = `${this.#config.title || "System Performance"}`;

		// Initial update
		this.#updateMetrics();
	}

	/**
	 * @description Stops the periodic interval for updating metrics.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method stop

	 * @memberof AutoGenerated

	 */

		stop() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (this.#updateInterval) {
			clearInterval(this.#updateInterval);
			this.#updateInterval = null;
		}
		this.#isActive = false;
		this.#container.style.opacity = "0.5";
		this.#titleElement.textContent = `${this.#config.title || "System Performance"} (Paused)`;
	}

	/**
	 * @description Toggles the active state of the monitoring, pausing or resuming updates.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method toggle

	 * @memberof AutoGenerated

	 */

		toggle() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (this.#isActive) {
			this.stop();
		} else {
			this.start();
		}
	}

	/**
	 * Sets up event listeners for the component.
	 * @private
	 */
	#setupEventListeners() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

				if (this.#config.clickToToggle !== false) {
			this.#titleElement.style.cursor = "pointer";
			this.#titleElement.title = "Click to pause/resume monitoring";
			this.#titleElement.addEventListener("click", () => this.toggle());
		}
	}

	/**
	 * Sets up a MutationObserver to clean up resources when the element is removed from the DOM.
	 * @private
	 */
	#setupCleanupObserver() {
		const observer = new MutationObserver((mutations, obs) => {
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

						for (const mutation of mutations) {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

								for (const node of mutation.removedNodes) {
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

										if (node === this.#container) {
						this.stop();
						obs.disconnect();
						return;
					}
				}
			}
		});

		// The observer must be attached to the PARENT node.
		// We can't know the parent until this element is added to the DOM.
		// A second observer on the element itself detects when it's attached.
		const parentObserver = new MutationObserver(() => {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

						if (this.#container.parentNode) {
				observer.observe(this.#container.parentNode, {
					childList: true,
				});
				parentObserver.disconnect();
			}
		});
		parentObserver.observe(document.body, {
			childList: true,
			subtree: true,
		});
	}

	/**
	 * Returns the main DOM element for the block.
	 * @public
	 * @returns {HTMLElement}
	 */
	/**

	 * TODO: Add JSDoc for method render

	 * @memberof AutoGenerated

	 */

		render() {
		return this.#container;
	}
}

/**
 * @function PerformanceOverlayBlock
 * @description A factory function that creates and returns the DOM element for the performance overlay.
 * This maintains compatibility with the original functional block signature.
 * @param {object} params - The parameters for rendering the block.
 * @param {import('../../core/RenderContext.js').RenderContext} params.context - The rendering context.
 * @param {object} [params.config={}] - Configuration options for the block.
 * @returns {HTMLElement} The rendered HTML element for the performance overlay.
 */
export function PerformanceOverlayBlock({ context, config = {} }) {
	const block = new PerformanceOverlayBlock_V2({
		context,
		config,
	});
	const element = block.render();

	// Expose control methods for external access, adhering to a cleaner pattern
	element.performanceOverlay = {
		start: () => block.start(),
		stop: () => block.stop(),
		toggle: () => block.toggle(),
		update: () => block.update(),
		isActive: () => block.isActive(),
	};

	return element;
}

/**
 * @function registerPerformanceOverlayBlock
 * @description Registers the `PerformanceOverlayBlock` with the `BuildingBlockRenderer`,
 * making it available for use in compositions.
 * @param {import('../../core/BuildingBlockRenderer.js').BuildingBlockRenderer} renderer - The renderer instance to register with.
 * @returns {void}
 */
export function registerPerformanceOverlayBlock(renderer) {
	renderer.registerBlock("performance_overlay", {
		render: PerformanceOverlayBlock,
		config: {
			title: "System Performance",
			refreshRate: 2000,
			autoStart: true,
			clickToToggle: true,
			overlay: false,
			fontSize: "12px",
			padding: "1rem",
		},
		dependencies: ["stateManager", "metricsRegistry"],
	});
}

/**
 * @function createPerformanceOverlay
 * @description A factory function to create a composition object for the `PerformanceOverlayBlock`.
 * @param {object} [config={}] - Configuration options for the block.
 * @returns {object} A composition object representing the performance overlay.
 */
export function createPerformanceOverlay(config = {}) {
	ForensicLogger.createEnvelope({
		actorId: "system",
		action: "<auto>",
		target: "<unknown>",
		label: "unclassified",
	});
	return {
		type: "performance_overlay",
		config: {
			title: "Performance Monitor",
			overlay: true,
			refreshRate: 1000,
			...config,
		},
	};
}

export default PerformanceOverlayBlock;
