import { SafeDOM } from "@shared/lib/SafeDOM.js";
import { ForensicLogger } from "@platform/security/ForensicLogger.js";
// src/core/ui/VirtualList.js
// Lightweight, framework-free virtualized list with item recycling, keyboard nav,
// sticky headers, and resize-aware windowing. Works for rows or cards.
// Usage:
//   const vlist = new VirtualList({
//     container: document.querySelector('#list'),
//     itemHeight: 44, // or provide itemSize:(i)=>number for variable height
//     count: () => data.length,
//     render: (el, i) => { el.textContent = data[i].title; },
//     keyOf: (i) => data[i].id,
//   });
//   vlist.mount();

export class VirtualList {
	/**
	 * @param {Object} options
	 * @param {HTMLElement} options.container - Scrollable container (position:relative recommended)
	 * @param {number} [options.itemHeight] - Fixed height per row (px). Provide OR itemSize().
	 * @param {(index:number)=>number} [options.itemSize] - Variable size callback (px).
	 * @param {()=>number} options.count - Total item count getter
	 * @param {(el:HTMLElement, index:number)=>void} options.render - Render callback (recycles el)
	 * @param {(index:number)=>string|number} [options.keyOf] - Stable key extractor for recycling
	 * @param {number} [options.overscan=6] - Extra items before/after viewport
	 * @param {boolean} [options.recycle=true] - Reuse DOM nodes
	 * @param {boolean} [options.keyboard=true] - Enable arrow/page/home/end navigation
	 * @param {boolean} [options.stickyHeader=false] - Reserve 1 sticky header slot (index -1)
	 * @param {(el:HTMLElement)=>void} [options.renderHeader] - If stickyHeader, render header here
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor(options) {
		this.opt = {
			overscan: 6,
			recycle: true,
			keyboard: true,
			stickyHeader: false,
			...options,
		};
		if (!this.opt.container)
			throw new Error("VirtualList: container required");
		if (!this.opt.count || !this.opt.render)
			throw new Error("VirtualList: count/render required");
		if (!this.opt.itemHeight && !this.opt.itemSize)
			throw new Error("VirtualList: provide itemHeight or itemSize()");

		this._root = this.opt.container;
		this._root.setAttribute("role", "list");
		this._root.tabIndex = this._root.tabIndex || 0;
		this._root.style.overflow = this._root.style.overflow || "auto";
		this._root.style.position = this._root.style.position || "relative";

		this._viewportH = this._root.clientHeight;
		this._scrollTop = 0;
		this._pool = []; // recycled nodes
		this._inUse = new Map(); // index -> node
		this._keys = new Map(); // key -> node (for stable reuse)
		this._raf = 0;
		this._mounted = false;

		// inner spacer to simulate full height
		this._spacer = SafeDOM.createElement("div");
		this._spacer.style.position = "relative";
		this._spacer.style.width = "1px";
		this._spacer.style.height = "0px";

		// sticky header
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.opt.stickyHeader) {
			this._header = SafeDOM.createElement("div");
			this._header.style.position = "sticky";
			this._header.style.top = "0";
			this._header.style.zIndex = "1";
			this._header.style.willChange = "transform";
			this._root.appendChild(this._header);
			if (this.opt.renderHeader) this.opt.renderHeader(this._header);
		}

		this._root.appendChild(this._spacer);

		// observers
		this._onScroll = this._onScroll.bind(this);
		this._onResize = this._onResize.bind(this);
		this._onKey = this._onKey.bind(this);

		this._resizeObs = new ResizeObserver(this._onResize);
		this._resizeObs.observe(this._root);
	}

	/**


	 * TODO: Add JSDoc for method mount


	 * @memberof AutoGenerated


	 */

	mount() {
		if (this._mounted) return;
		this._mounted = true;
		this._root.addEventListener("scroll", this._onScroll, {
			passive: true,
		});
		if (this.opt.keyboard)
			this._root.addEventListener("keydown", this._onKey);
		this._syncTotalHeight();
		this._schedule();
	}

	/**


	 * TODO: Add JSDoc for method unmount


	 * @memberof AutoGenerated


	 */

	unmount() {
		if (!this._mounted) return;
		this._mounted = false;
		this._root.removeEventListener("scroll", this._onScroll);
		this._root.removeEventListener("keydown", this._onKey);
		this._resizeObs.disconnect();
		cancelAnimationFrame(this._raf);
		// cleanup DOM (keep container)
		for (const [, node] of this._inUse) node.remove();
		this._inUse.clear();
		this._pool.length = 0;
		this._keys.clear();
		this._spacer.remove();
		if (this._header) this._header.remove();
	}

	/**


	 * TODO: Add JSDoc for method refresh


	 * @memberof AutoGenerated


	 */

	refresh() {
		// call when data size or per-item height might have changed
		this._syncTotalHeight();
		this._schedule();
	}

	/**


	 * TODO: Add JSDoc for method scrollToIndex


	 * @memberof AutoGenerated


	 */

	scrollToIndex(index, align = "start") {
		const top = this._offsetOf(index);
		const height = this._sizeOf(index);
		const vp = this._root.clientHeight;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (align === "center") {
			this._root.scrollTop = Math.max(0, top - (vp - height) / 2);
		} else if (align === "end") {
			this._root.scrollTop = Math.max(0, top - (vp - height));
		} else {
			this._root.scrollTop = top;
		}
	}

	// ---------- internals ----------
	_onScroll() {
		this._scrollTop = this._root.scrollTop;
		this._schedule();
	}

	_onResize() {
		const next = this._root.clientHeight;
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (next !== this._viewportH) {
			this._viewportH = next;
			this._schedule();
		}
	}

	_schedule() {
		if (this._raf) cancelAnimationFrame(this._raf);
		this._raf = requestAnimationFrame(() => this._update());
	}

	_update() {
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		const count = this.opt.count();
		const vpTop = this._scrollTop;
		const vpBottom = vpTop + this._viewportH;
		const first = this._findFirstIndexAtOrAbove(vpTop);
		const last = this._findLastIndexAtOrBelow(vpBottom);
		const overscan = this.opt.overscan;

		const start = Math.max(0, first - overscan);
		const end = Math.min(count - 1, last + overscan);

		// recycle nodes not in range
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (const [i, node] of this._inUse) {
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (i < start || i > end) {
				this._inUse.delete(i);
				if (this.opt.recycle) this._pool.push(node);
				else node.remove();
			}
		}

		// ensure nodes for range
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (let i = start; i <= end; i++) {
			if (this._inUse.has(i)) continue;
			const key = this.opt.keyOf?.(i);
			let node = key != null ? this._keys.get(key) : undefined;
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (node && node.parentElement !== this._spacer) {
				// if key was reused elsewhere, drop it
				node = undefined;
			}

			if (!node) node = this._pool.pop() || this._makeItem();
			node.style.position = "absolute";
			node.style.left = "0";
			node.style.right = "0";
			node.style.transform = `translateY(${this._offsetOf(i)}px)`;
			node.style.height = this._sizeOf(i) + "px";

			// render content into recycled node
			node.dataset.index = String(i);
			this.opt.render(node, i);

			// mount under spacer
			this._spacer.appendChild(node);
			this._inUse.set(i, node);
			if (key != null) this._keys.set(key, node);
		}
	}

	_makeItem() {
		const el = SafeDOM.createElement("div");
		el.setAttribute("role", "listitem");
		el.style.willChange = "transform";
		el.style.contain = "content";
		return el;
	}

	_syncTotalHeight() {
		const count = this.opt.count();
		const total = this._offsetOf(count); // offset at end == cumulative height
		this._spacer.style.height = total + "px";
	}

	_sizeOf(i) {
		if (i < 0) return 0;
		return this.opt.itemHeight ?? this.opt.itemSize(i);
	}

	_offsetOf(i) {
		// cumulative height from 0..i-1
		if (i <= 0) return 0;
		if (this.opt.itemHeight) return i * this.opt.itemHeight;
		// variable size: cheap prefix sum
		let sum = 0;
		for (let k = 0; k < i; k++) sum += this.opt.itemSize(k);
		return sum;
	}

	_findFirstIndexAtOrAbove(y) {
		// binary search if fixed height
		const count = this.opt.count();
		if (this.opt.itemHeight)
			return Math.min(count - 1, Math.floor(y / this.opt.itemHeight));
		// linear fallback for variable size (can be swapped for indexed prefix table later)
		let sum = 0;
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (let i = 0; i < count; i++) {
			if (sum + this._sizeOf(i) > y) return i;
			sum += this._sizeOf(i);
		}
		return Math.max(0, count - 1);
	}

	_findLastIndexAtOrBelow(y) {
		const count = this.opt.count();
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.opt.itemHeight) {
			return Math.max(
				0,
				Math.min(count - 1, Math.floor(y / this.opt.itemHeight))
			);
		}
		let sum = 0;
		/**

		 * TODO: Add JSDoc for method for

		 * @memberof AutoGenerated

		 */

		for (let i = 0; i < count; i++) {
			const next = sum + this._sizeOf(i);
			if (next >= y) return i;
			sum = next;
		}
		return Math.max(0, count - 1);
	}

	_onKey(e) {
		const count = this.opt.count();
		if (!count) return;
		const cur = Number(
			this._root.querySelector('[data-index-focus="1"]')?.dataset.index ??
				-1
		);
		const visible = [...this._inUse.keys()].sort((a, b) => a - b);
		const top = visible[0] ?? 0;
		const bottom = visible[visible.length - 1] ?? 0;

		let target = cur;

		/**


		 * TODO: Add JSDoc for method switch


		 * @memberof AutoGenerated


		 */

		switch (e.key) {
			case "ArrowDown":
				target = Math.min(count - 1, cur >= 0 ? cur + 1 : top);
				break;
			case "ArrowUp":
				target = Math.max(0, cur >= 0 ? cur - 1 : bottom);
				break;
			case "PageDown":
				target = Math.min(count - 1, bottom);
				break;
			case "PageUp":
				target = Math.max(0, top);
				break;
			case "Home":
				target = 0;
				break;
			case "End":
				target = count - 1;
				break;
			default:
				return;
		}
		e.preventDefault();

		this.scrollToIndex(target, "start");
		// flag focus (consumer can style [data-index-focus="1"])
		const node = this._inUse.get(target);
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (node) {
			this._root
				.querySelectorAll('[data-index-focus="1"]')
				.forEach((n) => n.removeAttribute("data-index-focus"));
			node.setAttribute("data-index-focus", "1");
			node.focus?.();
		}
	}
}

export default VirtualList;
