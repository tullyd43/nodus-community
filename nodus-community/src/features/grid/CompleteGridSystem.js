/**
 * @file CompleteGridSystem.js
 * @description Integrates all grid-related features into a single, cohesive system.
 * This class is a managed service, instantiated by the ServiceRegistry, and orchestrates all other grid-related services.
 */

// Grid policies are managed via the GridPolicyService from the ServiceRegistry.

/**
 * @class CompleteGridSystem
 * @classdesc Manages the complete, enhanced grid system by initializing and coordinating
 * all managed grid services like policy management, toast notifications, and the AI layout assistant.
 * @privateFields {#stateManager, #options, #gridEnhancer, #toastManager, #aiAssistant, #initialized, #unsubscribeFunctions}
 * @privateFields {#stateManager, #appViewModel, #options, #gridEnhancer, #toastManager, #aiAssistant, #initialized, #unsubscribeFunctions}
 * @privateFields {#stateManager, #appViewModel, #options, #gridEnhancer, #toastManager, #aiAssistant, #gridPolicyService, #initialized, #unsubscribeFunctions, #asyncService}
 */
import { ForensicLogger } from "@core/security/ForensicLogger.js";
import { GridHistoryInspector } from "@grid/GridHistoryInspector.js";
import { componentRegistry } from "@grid/runtime/ComponentRegistry.js";
import { normalizeConfig } from "@grid/runtime/GridRuntimeConfig.js";
import { LayoutStore } from "@grid/runtime/LayoutStore.js";

export class CompleteGridSystem {
	/** @private @type {import('../core/HybridStateManager.js').default} */
	#stateManager;
	/** @private @type {import('../../grid/EnhancedGridRenderer.js').EnhancedGridRenderer|null} */
	#gridEnhancer = null;
	/** @private @type {import('../../shared/lib/SystemToastManager.js').SystemToastManager|null} */
	#toastManager = null;
	/** @private @type {import('../../grid/AILayoutAssistant.js').AILayoutAssistant|null} */
	#aiAssistant = null;
	/** @private @type {object} */
	#options;
	/** @private @type {object} */
	#appViewModel;
	/** @private @type {boolean} */
	#initialized = false;
	/** @private @type {Function[]} */
	#unsubscribeFunctions = [];
	/** @private @type {import('../../grid/GridPolicyIntegration.js').GridPolicyService|null} */
	#gridPolicyService = null;
	/** @private @type {LayoutStore|null} */
	#layoutStore = null;
	/** @private */
	#runtimeConfig = null;
	#nestedGridManager = null;
	#historyInspector = null;
	#asyncService = null;

	/**
	 * Creates an instance of CompleteGridSystem.
	 * @param {object} context - The context object provided by the ServiceRegistry.
	 * @param {import('../core/HybridStateManager.js').default} context.stateManager - The application's state manager.
	 * @param {object} [options={}] - Configuration options for the grid system.
	 * @param {string} [options.gridContainer=".grid-container"] - The CSS selector for the grid container element.
	 * @param {object} [context.appViewModel] - The main application view model, if available.
	 * @param {boolean} [options.enablePolicies=true] - Whether to enable grid-specific policy management.
	 * @param {boolean} [options.enableToasts=true] - Whether to enable toast notifications for grid events.
	 * @param {boolean} [options.enableAI=true] - Whether to enable the AI layout assistant.
	 * @param {boolean} [options.enableAnalytics=true] - Whether to enable analytics tracking for grid interactions.
	 */
	/**

	 * TODO: Add JSDoc for method constructor

	 * @memberof AutoGenerated

	 */

	constructor({ stateManager, appViewModel }, options = {}) {
		// V8.0 Parity: Accept appViewModel in constructor.
		this.#stateManager = stateManager;
		this.#appViewModel = appViewModel || {}; // V8.0 Parity: Assign appViewModel.
		this.#asyncService =
			this.#stateManager?.managers?.asyncOrchestrator ?? null;
		if (!this.#asyncService) {
			throw new Error(
				"CompleteGridSystem requires AsyncOrchestrationService on the state manager."
			);
		}

		// V8.0 Parity: Acquire all dependencies from the state manager.
		this.#toastManager = this.#stateManager.managers.toastManager;
		this.#aiAssistant = this.#stateManager.managers.aiLayoutAssistant;
		this.#gridEnhancer = this.#stateManager.managers.enhancedGridRenderer;
		this.#gridPolicyService = this.#stateManager.managers.gridPolicyService;
		try {
			this.#layoutStore = new LayoutStore({
				stateManager: this.#stateManager,
			});
		} catch {
			/* noop */
		}

		this.#options = {
			gridContainer: ".grid-container",
			enablePolicies: true,
			enableToasts: true,
			enableAI: true,
			enableAnalytics: true,
			enableNesting: false,
			...options,
		};
	}

	/**
	 * Initializes all configured subsystems of the grid system in the correct order.
	 * @public
	 * @returns {Promise<void>}
	 */
	/**

	 * TODO: Add JSDoc for method initialize

	 * @memberof AutoGenerated

	 */

	async initialize() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#initialized) {
			return; // idempotent: silently ignore repeated initialize calls
		}

		try {
			// 1. Extend SystemPolicies with grid policies
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#options.enablePolicies && this.#gridPolicyService) {
				await this.#gridPolicyService.registerGridPolicies({
					includeNesting: !!this.#options.enableNesting,
				});
			}

			// 2. Initialize grid enhancer with all features
			await this.#initializeGridEnhancer();

			// 3. Set up policy management UI
			this.#setupPolicyControls();

			// 4. Set up analytics tracking
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#options.enableAnalytics) {
				this.#setupAnalytics();
				this.#setupAnalyticsPanel();
			}

			// 5. History inspector (lightweight)
			try {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#options.enableHistoryInspector !== false) {
					this.#historyInspector = new GridHistoryInspector({
						stateManager: this.#stateManager,
					});
					this.#historyInspector.initialize();
				}
			} catch {
				/* noop */
			}

			// 6. Nested grid manager is tenant-gated and loaded lazily when enabled
			try {
				this.#setupNestingPolicyWatcher();
			} catch {
				/* noop */
			}

			// 7. Listen for grid add requests from reusable button component
			try {
				const handler = (payload) =>
					this.#onAddBlockRequested(payload || {});
				this.#unsubscribeFunctions.push(
					this.#stateManager.on("gridAddBlockRequested", handler)
				);
			} catch {
				/* noop */
			}

			this.#initialized = true;
			console.log("Complete Grid System initialized with all features");

			// Show initialization success
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#toastManager) {
				this.#toastManager.success(
					"ðŸŽ¯ Enhanced grid system ready",
					3000
				);
			}
		} catch (error) {
			console.error("Failed to initialize complete grid system:", error);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (this.#toastManager) {
				this.#toastManager.error(
					"Failed to initialize grid enhancements",
					5000
				);
			}
		}
	}

	#onAddBlockRequested(payload) {
		try {
			const mode = String(payload.mode || "modal");
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (mode === "add") {
				this.#addBlockDirect();
			} else {
				this.#openAddElementModal();
			}
		} catch {
			/* noop */
		}
	}

	#addBlockDirect() {
		try {
			const cfg = this.#runtimeConfig || { blocks: [] };
			const columns = Number(
				this.#stateManager?.managers?.policies?.getPolicy(
					"grid",
					"default_columns"
				) ?? 24
			);
			const w = 6,
				h = 4;
			const x = Math.max(0, Math.floor((columns - w) / 2));
			const yBase = cfg.blocks.reduce(
				(m, b) => Math.max(m, (b.y ?? 0) + (b.h ?? 0)),
				0
			);
			const b = {
				id: `block_${Date.now()}`,
				type: "block",
				x,
				y: yBase,
				w,
				h,
				constraints: { minW: 2, minH: 2, maxW: columns, maxH: 1000 },
				props: { title: "Block", body: "New" },
			};
			cfg.blocks.push(b);
			this.#appendBlock(b);
			this.saveRuntimeConfig("dev-default").catch(() => {});
		} catch {
			/* noop */
		}
	}

	#appendBlock(b) {
		const container =
			document.querySelector(this.#options.gridContainer) ||
			document.querySelector(".grid-container") ||
			document.body;
		const block = document.createElement("div");
		block.className = "grid-block";
		block.dataset.blockId = b.id;
		block.dataset.minW = String(b.constraints.minW);
		block.dataset.minH = String(b.constraints.minH);
		block.dataset.maxW = String(b.constraints.maxW);
		block.dataset.maxH = String(b.constraints.maxH);
		const content = document.createElement("div");
		content.className = "grid-block-content";
		block.appendChild(content);
		container.appendChild(block);
		try {
			componentRegistry.mount(b.type, content, b.props || {}, {
				stateManager: this.#stateManager,
				appViewModel: this.#appViewModel,
				parentConfigId: "dev-default",
				blockId: b.id,
			});
		} catch {
			/* noop */
		}
		this.#gridEnhancer?.updateBlockPosition?.(b.id, b.x, b.y, b.w, b.h);
	}

	#openAddElementModal() {
		const existing = document.getElementById("grid-add-modal");
		if (existing) existing.remove();
		const wrap = document.createElement("div");
		wrap.id = "grid-add-modal";
		wrap.style.cssText =
			"position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:20000;display:flex;align-items:center;justify-content:center;";
		const card = document.createElement("div");
		card.style.cssText =
			"background:#fff;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.3);width:420px;max-width:90vw;padding:16px;";
		// Build modal content programmatically to avoid innerHTML usage
		const header = document.createElement("h3");
		header.style.margin = "0 0 10px";
		header.textContent = "Add Grid Block";

		const typeLabel = document.createElement("label");
		typeLabel.style.display = "block";
		typeLabel.style.marginBottom = "8px";
		const typeSpan = document.createElement("span");
		typeSpan.textContent = "Component Type";
		const typeSelect = document.createElement("select");
		typeSelect.id = "gb-type";
		typeSelect.style.width = "100%";
		typeSelect.style.padding = "8px";
		typeSelect.style.marginTop = "4px";
		[
			["block", "Block"],
			["text", "Text"],
			["html", "HTML"],
		].forEach(([val, label]) => {
			const opt = document.createElement("option");
			opt.value = val;
			opt.textContent = label;
			typeSelect.appendChild(opt);
		});
		typeLabel.appendChild(typeSpan);
		typeLabel.appendChild(typeSelect);

		const titleLabel = document.createElement("label");
		titleLabel.style.display = "block";
		titleLabel.style.marginBottom = "8px";
		const titleSpan = document.createElement("span");
		titleSpan.textContent = "Title/Text";
		const titleInput = document.createElement("input");
		titleInput.id = "gb-title";
		titleInput.type = "text";
		titleInput.style.width = "100%";
		titleInput.style.padding = "8px";
		titleInput.style.marginTop = "4px";
		titleInput.placeholder = "Title or text";
		titleLabel.appendChild(titleSpan);
		titleLabel.appendChild(titleInput);

		const actions = document.createElement("div");
		actions.style.display = "flex";
		actions.style.gap = "8px";
		actions.style.justifyContent = "flex-end";
		actions.style.marginTop = "12px";
		const cancelBtn = document.createElement("button");
		cancelBtn.id = "gb-cancel";
		cancelBtn.style.padding = "8px 12px";
		cancelBtn.textContent = "Cancel";
		const addBtn = document.createElement("button");
		addBtn.id = "gb-add";
		addBtn.style.padding = "8px 12px";
		addBtn.style.background = "#2b7cff";
		addBtn.style.color = "#fff";
		addBtn.style.border = "0";
		addBtn.style.borderRadius = "6px";
		addBtn.textContent = "Add";
		actions.appendChild(cancelBtn);
		actions.appendChild(addBtn);

		card.appendChild(header);
		card.appendChild(typeLabel);
		card.appendChild(titleLabel);
		card.appendChild(actions);
		wrap.appendChild(card);
		document.body.appendChild(wrap);
		const cancel = () => wrap.remove();
		wrap.addEventListener("click", (e) => {
			if (e.target === wrap) cancel();
		});
		card.querySelector("#gb-cancel").addEventListener("click", cancel);
		card.querySelector("#gb-add").addEventListener("click", () => {
			try {
				const type = card.querySelector("#gb-type").value;
				const title =
					card.querySelector("#gb-title").value ||
					(type === "text" ? "Text" : "Block");
				const columns = Number(
					this.#stateManager?.managers?.policies?.getPolicy(
						"grid",
						"default_columns"
					) ?? 24
				);
				const w = 6,
					h = 4;
				const x = Math.max(0, Math.floor((columns - w) / 2));
				const yBase = (this.#runtimeConfig?.blocks || []).reduce(
					(m, b) => Math.max(m, (b.y ?? 0) + (b.h ?? 0)),
					0
				);
				const props =
					type === "block"
						? { title, body: "" }
						: type === "text"
							? { value: title }
							: { html: title };
				const b = {
					id: `block_${Date.now()}`,
					type,
					x,
					y: yBase,
					w,
					h,
					constraints: {
						minW: 2,
						minH: 2,
						maxW: columns,
						maxH: 1000,
					},
					props,
				};
				this.#runtimeConfig = this.#runtimeConfig || { blocks: [] };
				this.#runtimeConfig.blocks.push(b);
				this.#appendBlock(b);
				this.saveRuntimeConfig("dev-default").catch(() => {});
				cancel();
			} catch {
				cancel();
			}
		});
	}

	/**
	 * Applies a runtime configuration to the grid: creates blocks and mounts components.
	 * Prefer calling this before the first initialize(), so the renderer can enhance on first pass.
	 * @param {object} rawConfig
	 */
	/**

	 * TODO: Add JSDoc for method setRuntimeConfig

	 * @memberof AutoGenerated

	 */

	async setRuntimeConfig(rawConfig, id = "default", scope = null, depth = 0) {
		try {
			const maxDepth = Number(
				this.#stateManager?.managers?.policies?.getPolicy(
					"grid",
					"nesting_max_depth"
				) ?? 3
			);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (depth > maxDepth) {
				console.warn(
					`[Grid] Max nesting depth of ${maxDepth} exceeded. Aborting render.`
				);
				const container =
					document.querySelector(this.#options.gridContainer) ||
					document.body;
				container.textContent = "[max nesting depth exceeded]";
				return;
			}

			this.#runtimeConfig = normalizeConfig(rawConfig);
			// Enforce allowed component types via policy (if defined)
			try {
				const allowed =
					this.#stateManager?.managers?.policies?.getPolicy(
						"grid",
						"allowed_component_types"
					);
				if (Array.isArray(allowed) && allowed.length) {
					componentRegistry.setAllowedTypes(allowed);
				}
			} catch {
				/* noop */
			}
			const container =
				document.querySelector(this.#options.gridContainer) ||
				document.querySelector(".grid-container") ||
				document.body;
			// Clear container and rebuild blocks
			while (container.firstChild)
				container.removeChild(container.firstChild);

			// V8.0 Parity: Enforce unique IDs and prevent trivial overlaps
			const seen = new Set();
			this.#runtimeConfig.blocks = this.#runtimeConfig.blocks.filter(
				(b) => {
					if (seen.has(b.id)) {
						console.warn(
							`[Grid] Duplicate block ID found and removed: ${b.id}`
						);
						return false;
					}
					seen.add(b.id);
					return true;
				}
			);

			/**

			 * TODO: Add JSDoc for function overlaps

			 * @memberof AutoGenerated

			 */

			function overlaps(a, b) {
				const ax2 = a.x + a.w - 1,
					bx2 = b.x + b.w - 1;
				const ay2 = a.y + a.h - 1,
					by2 = b.y + b.h - 1;
				const colsOverlap = !(ax2 < b.x || bx2 < a.x);
				const rowsOverlap = !(ay2 < b.y || by2 < a.y);
				return colsOverlap && rowsOverlap;
			}
			const out = [];
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of this.#runtimeConfig.blocks) {
				if (out.some((x) => overlaps(x, b))) continue;
				out.push(b);
			}
			this.#runtimeConfig.blocks = out;
			// Use responsive template if present for current width
			const pickBlocks = () => {
				if (!this.#runtimeConfig?.templates)
					return this.#runtimeConfig.blocks;
				const bp = this.#getBreakpoint(window.innerWidth);
				return (
					this.#runtimeConfig.templates?.[bp]?.blocks ||
					this.#runtimeConfig.blocks
				);
			};
			const blocks = pickBlocks();
			/**

			 * TODO: Add JSDoc for method for

			 * @memberof AutoGenerated

			 */

			for (const b of blocks) {
				const block = document.createElement("div");
				block.className = "grid-block";
				block.dataset.blockId = b.id;
				block.dataset.minW = String(b.constraints.minW);
				block.dataset.minH = String(b.constraints.minH);
				block.dataset.maxW = String(b.constraints.maxW);
				block.dataset.maxH = String(b.constraints.maxH);
				// content wrapper
				const content = document.createElement("div");
				content.className = "grid-block-content";
				block.appendChild(content);
				container.appendChild(block);
				// mount component (pass parent config id and block id for nested persistence)
				try {
					await componentRegistry.mount(
						b.type,
						content,
						b.props || {},
						{
							stateManager: this.#stateManager,
							appViewModel: this.#appViewModel,
							parentConfigId: id,
							blockId: b.id,
							depth: depth + 1,
						}
					);
				} catch {
					/* noop */
				}
				// Optional: attach nested grid strictly inside block content
				try {
					if (
						this.#nestedGridManager &&
						b?.nestedGrid &&
						this.#stateManager?.managers?.policies?.getPolicy(
							"grid",
							"nesting_enabled"
						)
					) {
						await this.#nestedGridManager.attach(
							block,
							this.#appViewModel,
							b.nestedGrid,
							depth
						);
					}
				} catch {
					/* noop */
				}
			}
			// If renderer already initialized, refresh to enhance new blocks
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (this.#gridEnhancer?.refresh) {
				this.#gridEnhancer.refresh();
			} else if (this.#gridEnhancer?.initialize) {
				await this.#gridEnhancer.initialize({
					container,
					appViewModel: this.#appViewModel,
				});
			}

			// Restore last-known layout for this config
			await this.loadRuntimeLayout(id, scope);

			// Listen for breakpoint changes to re-apply template positions
			this.#setupResponsiveTemplateListener(id);
		} catch (err) {
			console.warn("[Grid] setRuntimeConfig failed:", err);
		}
	}

	/** Saves the current runtime config to persistent storage */
	/**

	 * TODO: Add JSDoc for method saveRuntimeConfig

	 * @memberof AutoGenerated

	 */

	async saveRuntimeConfig(id = "default", scope = null) {
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		try {
			if (!this.#layoutStore || !this.#runtimeConfig) return;
			const sc = scope || this.#computeScopeFromPolicy();
			// V8.0 Parity: Add retry logic for constraint errors
			try {
				await this.#layoutStore.saveConfig(id, this.#runtimeConfig, sc);
			} catch (err) {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (err?.name === "ConstraintError") {
					await this.#layoutStore.deleteConfig(id, sc);
					await this.#layoutStore.saveConfig(
						id,
						this.#runtimeConfig,
						sc
					);
				} else throw err;
			}
			await this.#layoutStore.saveConfig(id, this.#runtimeConfig, sc);
		} catch (err) {
			console.warn("[Grid] saveRuntimeConfig failed:", err);
		}
	}

	/** Loads a runtime config and applies it, then restores layout if any */
	/**

	 * TODO: Add JSDoc for method loadRuntimeConfig

	 * @memberof AutoGenerated

	 */

	async loadRuntimeConfig(id = "default", scope = null) {
		try {
			if (!this.#layoutStore) return;
			const sc = scope || this.#computeScopeFromPolicy();
			const cfg = await this.#layoutStore.loadConfig(id, sc);
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (cfg) {
				await this.setRuntimeConfig(cfg, id, sc);
			} else {
				console.warn("[Grid] No runtime config found for id", id);
			}
		} catch (err) {
			console.warn("[Grid] loadRuntimeConfig failed:", err);
		}
	}

	#getBreakpoint(width) {
		if (width >= 1400) return "xxl";
		if (width >= 1200) return "xl";
		if (width >= 992) return "lg";
		if (width >= 768) return "md";
		if (width >= 576) return "sm";
		return "xs";
	}

	#setupResponsiveTemplateListener(id) {
		if (!this.#runtimeConfig?.templates) return;
		let lastBp = this.#getBreakpoint(window.innerWidth);
		const onResize = () => {
			const bp = this.#getBreakpoint(window.innerWidth);
			if (bp === lastBp) return;
			lastBp = bp;
			const tpl = this.#runtimeConfig.templates?.[bp];
			if (!tpl?.blocks || !this.#gridEnhancer?.updateBlockPosition)
				return;
			// Batch as a single history entry when available
			const apply = () => {
				/**

				 * TODO: Add JSDoc for method for

				 * @memberof AutoGenerated

				 */

				for (const b of tpl.blocks) {
					this.#gridEnhancer.updateBlockPosition(
						b.id,
						b.x,
						b.y,
						b.w,
						b.h
					);
				}
				// Persist new positions under the same id
				this.saveRuntimeLayout(id).catch(() => {});
			};
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.transaction === "function") {
				this.#stateManager.transaction(apply);
			} else {
				apply();
			}
		};
		window.addEventListener("resize", onResize);
		this.#unsubscribeFunctions.push(() =>
			window.removeEventListener("resize", onResize)
		);
	}

	/**
	 * Saves the current grid layout to persistent storage under the given id.
	 * @param {string} id
	 */
	/**

	 * TODO: Add JSDoc for method saveRuntimeLayout

	 * @memberof AutoGenerated

	 */

	async saveRuntimeLayout(id = "default", scope = null, layoutOverride = null) {
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		try {
			if (!this.#layoutStore) return;
			const runPersist = async () => {
				const layout =
					layoutOverride ||
					this.#gridEnhancer?.getCurrentLayout?.();
				if (!layout) return;
				const sc = scope || this.#computeScopeFromPolicy();
				try {
					await this.#layoutStore.save(id, layout, sc);
				} catch (err) {
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (err?.name === "ConstraintError") {
						await this.#layoutStore.delete(id, sc);
						await this.#layoutStore.save(id, layout, sc);
					} else throw err;
				}
			};
			await this.#asyncService.wrap(runPersist, {
				stateManager: this.#stateManager,
				label: "grid:layoutSave",
				meta: { source: "CompleteGridSystem.saveRuntimeLayout" },
			});
		} catch (err) {
			console.warn("[Grid] saveRuntimeLayout failed:", err);
		}
	}

	/**
	 * Loads a saved layout and applies positions to the renderer.
	 * @param {string} id
	 */
	/**

	 * TODO: Add JSDoc for method loadRuntimeLayout

	 * @memberof AutoGenerated

	 */

	async loadRuntimeLayout(id = "default", scope = null) {
		try {
			if (!this.#layoutStore || !this.#gridEnhancer) return;
			const sc = scope || this.#computeScopeFromPolicy();
			const layout = await this.#layoutStore.load(id, sc);
			if (!layout?.blocks || !Array.isArray(layout.blocks)) return;
			const positions = layout.blocks.map((b) => ({
				blockId: b.blockId,
				x: b.position?.x ?? b.x,
				y: b.position?.y ?? b.y,
				w: b.position?.w ?? b.w,
				h: b.position?.h ?? b.h,
			}));
			const apply = () => {
				this.#gridEnhancer.updateBlockPosition &&
					positions.forEach((p) => {
						this.#gridEnhancer.updateBlockPosition(
							p.blockId,
							p.x,
							p.y,
							p.w,
							p.h
						);
					});
			};
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.transaction === "function") {
				this.#stateManager.transaction(apply);
			} else {
				apply();
			}
		} catch (err) {
			console.warn("[Grid] loadRuntimeLayout failed:", err);
		}
	}

	#computeScopeFromPolicy() {
		try {
			const subj =
				this.#stateManager?.managers?.securityManager?.getSubject?.() ||
				{};
			const scopePref = String(
				this.#stateManager?.managers?.policies?.getPolicy(
					"system",
					"grid_auto_save_layout_scope"
				) || "tenant"
			).toLowerCase();
			if (scopePref === "user")
				return { tenantId: subj.tenantId, userId: subj.userId };
			if (scopePref === "tenant")
				return { tenantId: subj.tenantId, userId: "tenant" };
			return { tenantId: "global", userId: "global" };
		} catch {
			return { tenantId: "public", userId: "anon" };
		}
	}

	/**
	 * Initializes the `EnhancedGridRenderer` with all configured features and event listeners.
	 * @private
	 */
	async #initializeGridEnhancer() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (!this.#gridEnhancer) {
			throw new Error(
				"EnhancedGridRenderer not available from state manager."
			);
		}

		// V8.0 Parity: Initialize the EnhancedGridRenderer with its specific configuration.
		await this.#gridEnhancer.initialize({
			container: document.querySelector(this.#options.gridContainer),
			appViewModel: this.#appViewModel,
		});

		// Listen for layout changes to persist them via central event bus
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.on) {
			this.#unsubscribeFunctions.push(
				this.#stateManager.on(
					"layoutChanged",
					this.#onLayoutChanged.bind(this)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on(
					"grid:layoutChange",
					(payload) => {
						try {
							const policies =
								this.#stateManager?.managers?.policies;
							const autoSave = policies?.getPolicy?.(
								"system",
								"grid_auto_save_layouts"
							);
							if (!autoSave) return;
							const showFeedback = policies?.getPolicy?.(
								"system",
								"grid_save_feedback"
							);
							const layoutId =
								policies?.getPolicy?.(
									"system",
									"grid_auto_save_layout_id"
								) || "default";
							const scope = this.#computeScopeFromPolicy();
							const snapshot =
								payload &&
								typeof payload === "object" &&
								payload.layout &&
								typeof payload.layout === "object"
									? payload.layout
									: null;
							void this.saveRuntimeLayout(
								layoutId,
								scope,
								snapshot
							)
								.then(() => {
									if (showFeedback && this.#toastManager) {
										this.#toastManager.success(
											"Layout auto-saved",
											1500
										);
									}
								})
								.catch(() => {});
						} catch {
							/* noop */
						}
					}
				)
			);
		}

		// Listen for grid events
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.on) {
			this.#unsubscribeFunctions.push(
				this.#stateManager.on(
					"gridEnhanced",
					this.#onGridEnhanced.bind(this)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on(
					"gridPerformanceMode",
					this.#onPerformanceModeChanged.bind(this)
				)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("gridColumnsChanged", (data) => {
					if (!data) return;
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (this.#toastManager) {
						const isWarn =
							Number.isFinite(data.clampedCount) &&
							data.clampedCount > 0;
						const msg = isWarn
							? `Grid columns set to ${data.columns}. Adjusted ${data.clampedCount} blocks to fit.`
							: `Grid columns set to ${data.columns}.`;
						const method = isWarn ? "warning" : "info";
						this.#toastManager[method](msg, 2500);
					}
				})
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (this.#options.enableAI) {
				this.#unsubscribeFunctions.push(
					this.#stateManager.on(
						"aiLayoutSuggestions",
						this.#onAISuggestions.bind(this)
					)
				);
			}
		}

		// Listen for policy events to react to runtime changes
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.on) {
			const policyHandler = (evt) => {
				try {
					if (evt?.type !== "policy_updated") return;
					const { domain, key, newValue } = evt.data || {};
					// Update component whitelist immediately
					if (
						domain === "grid" &&
						key === "allowed_component_types" &&
						Array.isArray(newValue)
					) {
						componentRegistry.setAllowedTypes(newValue);
					}
					if (
						domain === "grid" &&
						key === "default_columns" &&
						Number.isInteger(newValue)
					) {
						this.#gridEnhancer?.setGridColumns?.(newValue);
					}
				} catch {
					/* noop */
				}
			};
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("policyEvent", policyHandler)
			);
		}

		// Global keyboard shortcuts for undo/redo (Ctrl+Z / Ctrl+Y)
		const keyHandler = (e) => {
			if (!e.ctrlKey && !e.metaKey) return;
			const k = e.key?.toLowerCase();
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (k === "z") {
				e.preventDefault();
				this.undoLayoutChange();
			}
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (k === "y") {
				e.preventDefault();
				this.redoLayoutChange();
			}
		};
		document.addEventListener("keydown", keyHandler);
		this.#unsubscribeFunctions.push(() =>
			document.removeEventListener("keydown", keyHandler)
		);
	}

	/**
	 * Handles layout change events by persisting them and feeding them to other subsystems.
	 * @private
	 * @param {object} changeEvent - The event data for the layout change.
	 */
	#onLayoutChanged(changeEvent) {
		// Save to HybridStateManager
		this.#stateManager.recordOperation({
			type: "grid_layout_change",
			data: changeEvent,
		});

		// Track analytics
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#options.enableAnalytics) {
			this.#trackLayoutChange(changeEvent);
		}

		// Auto-save now handled via grid:layoutChange event emitted by EnhancedGridRenderer
	}

	/**
	 * Handles the event indicating that the grid enhancements are active.
	 * @private
	 * @param {object} data - The event data.
	 */
	#onGridEnhanced(data) {
		console.log("Grid enhancement active");

		// Show current policy status
		this.#showPolicyStatus();
	}

	/**
	 * Handles changes to the grid's performance mode.
	 * @private
	 * @param {object} data - The performance mode change event data.
	 */
	#onPerformanceModeChanged(data) {
		console.log("Performance mode changed:", data);

		// Could update UI indicators, analytics, etc.
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#options.enableAnalytics) {
			this.#trackPerformanceMode(data);
		}
	}

	/**
	 * Handles the receipt of new AI-generated layout suggestions.
	 * @private
	 * @param {object} data - The event data containing the suggestions.
	 */
	#onAISuggestions(data) {
		console.log("AI suggestions received:", data.suggestions);

		// Show suggestions in UI (future implementation)
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#toastManager) {
			this.#toastManager.info(
				`ðŸ’¡ ${data.suggestions.length} layout suggestions available`,
				5000
			);
		}
	}

	/**
	 * Creates and injects the UI panel for managing grid-related policies.
	 * @private
	 */
	#setupPolicyControls() {
		// Add policy control panel to page
		const controlPanel = this.#createPolicyControlPanel();

		// Find a good place to insert it (or create a floating panel)
		const sidebar = document.querySelector(".sidebar");
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (sidebar) {
			sidebar.appendChild(controlPanel);
		} else {
			// Create floating panel
			controlPanel.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        padding: 16px;
        z-index: 1000;
        max-width: 250px;
      `;
			document.body.appendChild(controlPanel);
		}
	}

	/** Simple wrappers to integrate with HybridStateManager history (if available) */
	/**

	 * TODO: Add JSDoc for method undoLayoutChange

	 * @memberof AutoGenerated

	 */

	undoLayoutChange() {
		try {
			// V8.0 Parity: Use the state manager's history API for undo.
			// The history API is designed to handle transactions and state restoration.
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.history?.undo === "function") {
				this.#stateManager.history.undo();
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.info("Undo layout change", 1500);
				}
				this.#stateManager.emit("layoutRestored", {
					action: "undo",
					timestamp: Date.now(),
				});
			} else {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.warning(
						"Undo history not available",
						2000
					);
				}
			}
		} catch {
			this.#toastManager?.error("Undo failed", 2500);
			/* noop */
		}
	}

	/**


	 * TODO: Add JSDoc for method redoLayoutChange


	 * @memberof AutoGenerated


	 */

	redoLayoutChange() {
		try {
			// V8.0 Parity: Use the state manager's history API for redo.
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (typeof this.#stateManager?.history?.redo === "function") {
				this.#stateManager.history.redo();
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.info("Redo layout change", 1500);
				}
				this.#stateManager.emit("layoutRestored", {
					action: "redo",
					timestamp: Date.now(),
				});
			} else {
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (this.#toastManager) {
					this.#toastManager.warning(
						"Redo history not available",
						2000
					);
				}
			}
		} catch {
			this.#toastManager?.error("Redo failed", 2500);
			/* noop */
		}
	}

	/**
	 * Creates the HTML structure for the policy control panel.
	 * @private
	 * @returns {HTMLElement} The control panel element.
	 */
	#createPolicyControlPanel() {
		ForensicLogger.createEnvelope({
			actorId: "system",
			action: "<auto>",
			target: "<unknown>",
			label: "unclassified",
		});
		const panel = document.createElement("div");
		panel.className = "grid-policy-panel";

		// Header
		const header = document.createElement("h4");
		header.textContent = "Grid Settings";
		panel.appendChild(header);

		// helper to create checkbox control rows
		const checkboxControl = (id, labelText, help) => {
			const wrap = document.createElement("div");
			wrap.className = "policy-control";
			const label = document.createElement("label");
			const input = document.createElement("input");
			input.type = "checkbox";
			input.id = id;
			label.appendChild(input);
			label.appendChild(document.createTextNode(" " + labelText));
			wrap.appendChild(label);
			if (help) {
				const small = document.createElement("small");
				small.textContent = help;
				wrap.appendChild(small);
			}
			return wrap;
		};

		panel.appendChild(
			checkboxControl(
				"perf-mode-toggle",
				"Performance Mode",
				"Override automatic FPS-based switching"
			)
		);
		panel.appendChild(
			checkboxControl("auto-save-toggle", "Auto-save Layouts")
		);
		panel.appendChild(
			checkboxControl("save-feedback-toggle", "Save Notifications")
		);
		panel.appendChild(
			checkboxControl("ai-suggestions-toggle", "AI Suggestions")
		);

		// Tenant section
		panel.appendChild(document.createElement("hr"));
		const tHead = document.createElement("h5");
		tHead.textContent = "Tenant Overrides";
		panel.appendChild(tHead);
		const tInfo = document.createElement("small");
		tInfo.textContent =
			"Applies only to this tenant. Use Revert to return to global policy.";
		panel.appendChild(tInfo);

		// Tenant: performance select
		const tenantPerfRow = document.createElement("div");
		tenantPerfRow.className = "policy-control";
		tenantPerfRow.style.cssText =
			"margin-top:8px; display:flex; align-items:center; gap:8px;";
		const perfLabel = document.createElement("label");
		perfLabel.style.minWidth = "150px";
		perfLabel.textContent = "Performance Mode";
		const perfSelect = document.createElement("select");
		perfSelect.id = "tenant-perf-mode";
		[
			["auto", "Use Global / Auto"],
			["on", "Force On"],
			["off", "Force Off"],
		].forEach(([v, t]) => {
			const o = document.createElement("option");
			o.value = v;
			o.textContent = t;
			perfSelect.appendChild(o);
		});
		const perfRevert = document.createElement("button");
		perfRevert.id = "tenant-perf-revert";
		perfRevert.className = "btn-secondary";
		perfRevert.style.marginLeft = "auto";
		perfRevert.textContent = "Revert";
		tenantPerfRow.appendChild(perfLabel);
		tenantPerfRow.appendChild(perfSelect);
		tenantPerfRow.appendChild(perfRevert);
		panel.appendChild(tenantPerfRow);

		// Tenant: auto save
		const tenantAutoRow = document.createElement("div");
		tenantAutoRow.className = "policy-control";
		tenantAutoRow.style.cssText =
			"display:flex; align-items:center; gap:8px;";
		const tenantAutoLabel = document.createElement("label");
		tenantAutoLabel.style.minWidth = "150px";
		const tenantAutoInput = document.createElement("input");
		tenantAutoInput.type = "checkbox";
		tenantAutoInput.id = "tenant-auto-save-toggle";
		tenantAutoLabel.appendChild(tenantAutoInput);
		tenantAutoLabel.appendChild(
			document.createTextNode(" Auto-save Layouts")
		);
		const tenantAutoRevert = document.createElement("button");
		tenantAutoRevert.id = "tenant-auto-save-revert";
		tenantAutoRevert.className = "btn-secondary";
		tenantAutoRevert.style.marginLeft = "auto";
		tenantAutoRevert.textContent = "Revert";
		tenantAutoRow.appendChild(tenantAutoLabel);
		tenantAutoRow.appendChild(tenantAutoRevert);
		panel.appendChild(tenantAutoRow);

		// Tenant: save feedback
		const tenantSaveRow = document.createElement("div");
		tenantSaveRow.className = "policy-control";
		tenantSaveRow.style.cssText =
			"display:flex; align-items:center; gap:8px;";
		const tenantSaveLabel = document.createElement("label");
		tenantSaveLabel.style.minWidth = "150px";
		const tenantSaveInput = document.createElement("input");
		tenantSaveInput.type = "checkbox";
		tenantSaveInput.id = "tenant-save-feedback-toggle";
		tenantSaveLabel.appendChild(tenantSaveInput);
		tenantSaveLabel.appendChild(
			document.createTextNode(" Save Notifications")
		);
		const tenantSaveRevert = document.createElement("button");
		tenantSaveRevert.id = "tenant-save-feedback-revert";
		tenantSaveRevert.className = "btn-secondary";
		tenantSaveRevert.style.marginLeft = "auto";
		tenantSaveRevert.textContent = "Revert";
		tenantSaveRow.appendChild(tenantSaveLabel);
		tenantSaveRow.appendChild(tenantSaveRevert);
		panel.appendChild(tenantSaveRow);

		if (this.#options.enableNesting) {
			const tenantNestRow = document.createElement("div");
			tenantNestRow.className = "policy-control";
			tenantNestRow.style.cssText =
				"display:flex; align-items:center; gap:8px;";
			const tenantNestLabel = document.createElement("label");
			tenantNestLabel.style.minWidth = "150px";
			const tenantNestInput = document.createElement("input");
			tenantNestInput.type = "checkbox";
			tenantNestInput.id = "tenant-nesting-toggle";
			tenantNestLabel.appendChild(tenantNestInput);
			tenantNestLabel.appendChild(
				document.createTextNode(" Enable Nesting")
			);
			const tenantNestRevert = document.createElement("button");
			tenantNestRevert.id = "tenant-nesting-revert";
			tenantNestRevert.className = "btn-secondary";
			tenantNestRevert.style.marginLeft = "auto";
			tenantNestRevert.textContent = "Revert";
			tenantNestRow.appendChild(tenantNestLabel);
			tenantNestRow.appendChild(tenantNestRevert);
			panel.appendChild(tenantNestRow);
		}

		const resetButton = document.createElement("button");
		resetButton.id = "reset-policies";
		resetButton.className = "btn-secondary";
		resetButton.textContent = "Reset to Defaults";
		panel.appendChild(resetButton);

		// Add event listeners
		this.#setupPolicyEventListeners(panel);
		this.#setupTenantPolicyEventListeners(panel);

		// Load current policy states
		this.#loadCurrentPolicyStates(panel);

		return panel;
	}

	/**
	 * Attaches event listeners to the controls within the policy panel.
	 * @private
	 * @param {HTMLElement} panel - The policy control panel element.
	 */
	#setupPolicyEventListeners(panel) {
		const perfModeToggle = panel.querySelector("#perf-mode-toggle");
		const autoSaveToggle = panel.querySelector("#auto-save-toggle");
		const saveFeedbackToggle = panel.querySelector("#save-feedback-toggle");
		const aiSuggestionsToggle = panel.querySelector(
			"#ai-suggestions-toggle"
		);
		const resetButton = panel.querySelector("#reset-policies");

		perfModeToggle.addEventListener("change", async (e) => {
			const mode = e.target.checked ? true : null; // true = force on, null = auto
			await this.#setPolicyWithFeedback(
				"system.grid_performance_mode",
				mode
			);
		});

		autoSaveToggle.addEventListener("change", async (e) => {
			await this.#setPolicyWithFeedback(
				"system.grid_auto_save_layouts",
				e.target.checked
			);
		});

		saveFeedbackToggle.addEventListener("change", async (e) => {
			await this.#setPolicyWithFeedback(
				"system.grid_save_feedback",
				e.target.checked
			);
		});

		aiSuggestionsToggle.addEventListener("change", async (e) => {
			await this.#setPolicyWithFeedback(
				"system.grid_ai_suggestions",
				e.target.checked
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (e.target.checked && !this.#aiAssistant) {
				this.#aiAssistant =
					this.#stateManager.managers.aiLayoutAssistant;
			}
		});

		resetButton.addEventListener("click", () => {
			this.#resetPolicyDefaults();
		});
	}

	#setupTenantPolicyEventListeners(panel) {
		const svc = this.#gridPolicyService;
		if (!svc) return;

		const perfSelect = panel.querySelector("#tenant-perf-mode");
		const perfRevert = panel.querySelector("#tenant-perf-revert");
		const autoSaveToggle = panel.querySelector("#tenant-auto-save-toggle");
		const autoSaveRevert = panel.querySelector("#tenant-auto-save-revert");
		const saveFeedbackToggle = panel.querySelector(
			"#tenant-save-feedback-toggle"
		);
		const saveFeedbackRevert = panel.querySelector(
			"#tenant-save-feedback-revert"
		);
		const nestingToggle = panel.querySelector("#tenant-nesting-toggle");
		const nestingRevert = panel.querySelector("#tenant-nesting-revert");

		const toast = this.#toastManager;
		const okToast = (msg) => toast?.success?.(msg, 1500);
		const errToast = (msg) => toast?.error?.(msg, 2500);

		perfSelect?.addEventListener("change", async (e) => {
			const v = String(e.target.value);
			const val = v === "on" ? true : v === "off" ? false : null;
			try {
				await svc.setTenantPolicy("grid", "performance_mode", val);
				okToast?.("Tenant performance updated");
			} catch {
				errToast?.("Failed to update");
			}
		});

		perfRevert?.addEventListener("click", async () => {
			try {
				await svc.setTenantPolicy("grid", "performance_mode", null);
				if (perfSelect) perfSelect.value = "auto";
				okToast?.("Reverted to global");
			} catch {
				errToast?.("Failed to revert");
			}
		});

		autoSaveToggle?.addEventListener("change", async (e) => {
			try {
				await svc.setTenantPolicy(
					"grid",
					"auto_save_layouts",
					!!e.target.checked
				);
				okToast?.("Tenant auto-save updated");
			} catch {
				errToast?.("Failed to update");
			}
		});

		autoSaveRevert?.addEventListener("click", async () => {
			try {
				await svc.setTenantPolicy("grid", "auto_save_layouts", null);
				if (autoSaveToggle) autoSaveToggle.checked = false;
				okToast?.("Reverted to global");
			} catch {
				errToast?.("Failed to revert");
			}
		});

		saveFeedbackToggle?.addEventListener("change", async (e) => {
			try {
				await svc.setTenantPolicy(
					"grid",
					"save_feedback",
					!!e.target.checked
				);
				okToast?.("Tenant save-feedback updated");
			} catch {
				errToast?.("Failed to update");
			}
		});

		saveFeedbackRevert?.addEventListener("click", async () => {
			try {
				await svc.setTenantPolicy("grid", "save_feedback", null);
				if (saveFeedbackToggle) saveFeedbackToggle.checked = false;
				okToast?.("Reverted to global");
			} catch {
				errToast?.("Failed to revert");
			}
		});

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (nestingToggle && nestingRevert) {
			nestingToggle.addEventListener("change", async (e) => {
				try {
					await svc.setTenantPolicy(
						"grid",
						"nesting_enabled",
						!!e.target.checked
					);
					okToast?.("Tenant nesting updated");
				} catch {
					errToast?.("Failed to update");
				}
			});
			nestingRevert.addEventListener("click", async () => {
				try {
					await svc.setTenantPolicy("grid", "nesting_enabled", null);
					nestingToggle.checked = false;
					okToast?.("Reverted to global");
				} catch {
					errToast?.("Failed to revert"); /* noop */
				}
			});
		}
	}

	#setupNestingPolicyWatcher() {
		const handler = async (evt) => {
			const errToast = (msg) => this.#toastManager?.error?.(msg, 2500);
			try {
				if (
					!evt ||
					(evt.type !== "tenant_policy_updated" &&
						evt.type !== "policy_updated")
				)
					return;
				const { domain, key, newValue } = evt.data || {};
				if (domain !== "grid" || key !== "nesting_enabled") return;
				const enabled = Boolean(
					newValue ??
						this.#stateManager?.managers?.policies?.getPolicy(
							"grid",
							"nesting_enabled"
						)
				);
				/**

				 * TODO: Add JSDoc for method if

				 * @memberof AutoGenerated

				 */

				if (enabled) {
					await this.#gridPolicyService?.registerGridPolicies?.({
						includeNesting: true,
					});
					/**

					 * TODO: Add JSDoc for method if

					 * @memberof AutoGenerated

					 */

					if (!this.#nestedGridManager) {
						const mod = await import("@grid/NestedGridManager.js");
						this.#nestedGridManager = new mod.NestedGridManager({
							stateManager: this.#stateManager,
						});
					}
				} else {
					// Teardown: detach nested grids and release manager
					try {
						this.#nestedGridManager?.detachAll?.();
					} catch {
						errToast?.("Failed to update");
					}
					this.#nestedGridManager = null;
				}
			} catch {
				/* noop */
			}
		};
		this.#unsubscribeFunctions.push(
			this.#stateManager.on("policyEvent", handler)
		);
	}
	/**
	 * Sets a policy value and provides user feedback via a toast notification.
	 * @private
	 * @param {string} policyKey - The full key of the policy to set (e.g., 'system.grid_performance_mode').
	 * @param {*} value - The new value for the policy.
	 */
	async #setPolicyWithFeedback(policyKey, value) {
		try {
			// Use GridPolicyHelper or direct context access
			const [domain, key] = policyKey.split(".");
			await this.#stateManager.managers.policies.setPolicy(
				domain,
				key,
				value
			);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (this.#toastManager) {
				this.#toastManager.success(
					`Policy updated: ${policyKey}`,
					2000
				);
			}
		} catch (error) {
			console.error("Failed to set policy:", error);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (this.#toastManager) {
				this.#toastManager.error(
					`Failed to update policy: ${policyKey}`,
					3000
				);
			}
		}
	}

	/**
	 * Loads the current state of all grid-related policies and updates the control panel UI.
	 * @private
	 * @param {HTMLElement} panel - The policy control panel element.
	 */
	#loadCurrentPolicyStates(panel) {
		try {
			const policies = this.#gridPolicyService
				? this.#gridPolicyService.getGridPolicies()
				: {
						performanceMode: null,
						autoSave: true,
						saveFeedback: true,
						aiSuggestions: false,
					};

			panel.querySelector("#perf-mode-toggle").checked =
				policies.performanceMode === true;
			panel.querySelector("#auto-save-toggle").checked =
				policies.autoSave;
			panel.querySelector("#save-feedback-toggle").checked =
				policies.saveFeedback;
			panel.querySelector("#ai-suggestions-toggle").checked =
				policies.aiSuggestions;

			// Tenant section reflects effective values
			const perfSel = panel.querySelector("#tenant-perf-mode");
			/**

			 * TODO: Add JSDoc for method if

			 * @memberof AutoGenerated

			 */

			if (perfSel) {
				perfSel.value =
					policies.performanceMode === true
						? "on"
						: policies.performanceMode === false
							? "off"
							: "auto";
			}
			const as = panel.querySelector("#tenant-auto-save-toggle");
			if (as) as.checked = !!policies.autoSave;
			const sf = panel.querySelector("#tenant-save-feedback-toggle");
			if (sf) sf.checked = !!policies.saveFeedback;
			const nest = panel.querySelector("#tenant-nesting-toggle");
			if (nest)
				nest.checked =
					!!this.#stateManager?.managers?.policies?.getPolicy(
						"grid",
						"nesting_enabled"
					);
		} catch (error) {
			console.warn("Could not load current policy states:", error);
		}
	}

	/**
	 * Displays a toast notification summarizing the status of currently active grid policies.
	 * @private
	 */
	#showPolicyStatus() {
		try {
			const policies = this.#gridPolicyService
				? this.#gridPolicyService.getGridPolicies()
				: {
						performanceMode: null,
						autoSave: true,
						saveFeedback: true,
						aiSuggestions: false,
					};

			console.log("Current Grid Policies:", policies);

			/**


			 * TODO: Add JSDoc for method if


			 * @memberof AutoGenerated


			 */

			if (this.#toastManager) {
				const statusMessages = [];
				if (policies.performanceMode === true)
					statusMessages.push("ðŸš€ Performance mode forced");
				if (policies.performanceMode === false)
					statusMessages.push("âœ¨ Full features forced");
				if (!policies.autoSave)
					statusMessages.push("âš ï¸ Auto-save disabled");
				if (policies.aiSuggestions)
					statusMessages.push("ðŸ¤– AI suggestions enabled");

				/**


				 * TODO: Add JSDoc for method if


				 * @memberof AutoGenerated


				 */

				if (statusMessages.length > 0) {
					this.#toastManager.info(statusMessages.join(" â€¢ "), 4000);
				}
			}
		} catch (error) {
			console.warn("Could not show policy status:", error);
		}
	}

	/**
	 * Sets up event listeners to track grid interactions for analytics purposes.
	 * @private
	 */
	#setupAnalytics() {
		// Track grid usage patterns
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#unsubscribeFunctions.push(
				this.#stateManager.eventFlowEngine.on(
					"layoutChanged",
					(data) => {
						this.#trackLayoutChange(data);
					}
				)
			);

			this.#unsubscribeFunctions.push(
				this.#stateManager.eventFlowEngine.on(
					"gridPerformanceMode",
					(data) => {
						this.#trackPerformanceMode(data);
					}
				)
			);

			this.#unsubscribeFunctions.push(
				this.#stateManager.eventFlowEngine.on(
					"policyChanged",
					(data) => {
						if (
							data.domain === "system" &&
							data.key.startsWith("grid_")
						) {
							this.#trackPolicyChange(data);
						}
					}
				)
			);
		}
	}

	#setupAnalyticsPanel() {
		try {
			const el = document.createElement("div");
			el.id = "grid-analytics-panel";
			el.style.cssText = `
				position: fixed; right: 20px; top: 20px; z-index: 10000;
				background: rgba(20,20,20,0.85); color: #fff; padding: 10px 12px; border-radius: 8px;
				font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
				display: none; min-width: 180px; box-shadow: 0 6px 18px rgba(0,0,0,0.3);
			`;
			// Build analytics panel programmatically to avoid innerHTML
			const headerRow = document.createElement("div");
			headerRow.style.cssText =
				"display:flex;justify-content:space-between;align-items:center;gap:6px;margin-bottom:6px;";
			const strong = document.createElement("strong");
			strong.textContent = "Grid Analytics";
			const closeBtn = document.createElement("button");
			closeBtn.id = "ga-close";
			closeBtn.style.cssText =
				"background:#444;color:#fff;border:0;border-radius:4px;padding:2px 6px;cursor:pointer";
			closeBtn.textContent = "Ã—";
			headerRow.appendChild(strong);
			headerRow.appendChild(closeBtn);
			el.appendChild(headerRow);

			const fpsRow = document.createElement("div");
			fpsRow.appendChild(document.createTextNode("FPS: "));
			const fpsSpan = document.createElement("span");
			fpsSpan.id = "ga-fps";
			fpsSpan.textContent = "â€”";
			fpsRow.appendChild(fpsSpan);
			el.appendChild(fpsRow);

			const blocksRow = document.createElement("div");
			blocksRow.appendChild(document.createTextNode("Blocks: "));
			const blocksSpan = document.createElement("span");
			blocksSpan.id = "ga-blocks";
			blocksSpan.textContent = "â€”";
			blocksRow.appendChild(blocksSpan);
			el.appendChild(blocksRow);

			const visibleRow = document.createElement("div");
			visibleRow.appendChild(document.createTextNode("Visible: "));
			const visibleSpan = document.createElement("span");
			visibleSpan.id = "ga-visible";
			visibleSpan.textContent = "â€”";
			visibleRow.appendChild(visibleSpan);
			el.appendChild(visibleRow);

			const toggleInfo = document.createElement("div");
			toggleInfo.style.marginTop = "6px";
			toggleInfo.style.opacity = "0.8";
			toggleInfo.textContent = "Toggle: Alt+G";
			el.appendChild(toggleInfo);
			document.body.appendChild(el);
			const close = () => (el.style.display = "none");
			el.querySelector("#ga-close").addEventListener("click", close);

			// Toggle hotkey
			const onKey = (e) => {
				if (e.altKey && e.key?.toLowerCase() === "g") {
					e.preventDefault();
					el.style.display =
						el.style.display === "none" ? "block" : "none";
				}
			};
			document.addEventListener("keydown", onKey);
			this.#unsubscribeFunctions.push(() =>
				document.removeEventListener("keydown", onKey)
			);

			// Update handlers
			const setText = (sel, v) => {
				const n = el.querySelector(sel);
				if (n) n.textContent = String(v);
			};
			const onFps = ({ fps }) => setText("#ga-fps", fps ?? "â€”");
			const onVis = ({ inView, total }) => {
				setText("#ga-visible", inView ?? "â€”");
				setText("#ga-blocks", total ?? "â€”");
			};
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("gridFps", onFps)
			);
			this.#unsubscribeFunctions.push(
				this.#stateManager.on("gridBlockVisibility", onVis)
			);
		} catch {
			/* noop */
		}
	}

	/**
	 * Tracks a layout change event for analytics.
	 * @private
	 * @param {object} changeEvent - The layout change event data.
	 */
	#trackLayoutChange(changeEvent) {
		// Analytics tracking for layout changes
		const analyticsEvent = {
			category: "grid_interaction",
			action: changeEvent.changeType,
			label: changeEvent.blockId,
			value: 1,
			customDimensions: {
				userId: changeEvent.userId,
				autoSaved: changeEvent.autoSaved,
				position: `${changeEvent.position.x},${changeEvent.position.y}`,
				size: `${changeEvent.position.w}x${changeEvent.position.h}`,
			},
		};

		// Emit for analytics system
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#stateManager.eventFlowEngine.emit(
				"analyticsEvent",
				analyticsEvent
			);
		}
	}

	/**
	 * Tracks a performance mode change event for analytics.
	 * @private
	 * @param {object} data - The performance mode change event data.
	 */
	#trackPerformanceMode(data) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#stateManager.eventFlowEngine.emit("analyticsEvent", {
				category: "grid_performance",
				action: data.enabled
					? "performance_mode_on"
					: "performance_mode_off",
				label: data.reason,
				value: data.fps || 0,
			});
		}
	}

	/**
	 * Tracks a policy change event for analytics.
	 * @private
	 * @param {object} data - The policy change event data.
	 */
	#trackPolicyChange(data) {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#stateManager.eventFlowEngine) {
			this.#stateManager.eventFlowEngine.emit("analyticsEvent", {
				category: "grid_policy",
				action: "policy_changed",
				label: data.key,
				value: data.value ? 1 : 0,
			});
		}
	}

	/**
	 * Resets all grid-related policies to their default values.
	 * @private
	 */
	#resetPolicyDefaults() {
		// Reset all grid policies to defaults
		const defaults = {
			grid_performance_mode: null,
			grid_auto_save_layouts: true,
			grid_save_feedback: true,
			grid_ai_suggestions: false,
		};

		Object.entries(defaults).forEach(async ([key, value]) => {
			await this.#setPolicyWithFeedback(`system.${key}`, value);
		});

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (this.#toastManager) {
			this.#toastManager.success("Grid policies reset to defaults", 3000);
		}
	}

	// Public API

	/**


	 * TODO: Add JSDoc for method isInitialized


	 * @memberof AutoGenerated


	 */

	isInitialized() {
		return this.#initialized;
	}

	/**
	 * Cleans up all resources and event listeners used by the grid system.
	 * @public
	 */
	/**

	 * TODO: Add JSDoc for method destroy

	 * @memberof AutoGenerated

	 */

	destroy() {
		/**

		 * TODO: Add JSDoc for method if

		 * @memberof AutoGenerated

		 */

		if (this.#gridEnhancer) {
			this.#gridEnhancer.disable();
		}

		/**


		 * TODO: Add JSDoc for method if


		 * @memberof AutoGenerated


		 */

		if (this.#toastManager) {
			this.#toastManager.destroy();
		}

		// Remove event listeners
		this.#unsubscribeFunctions.forEach((unsubscribe) => unsubscribe());
		this.#unsubscribeFunctions = [];
	}
}

export default CompleteGridSystem;
